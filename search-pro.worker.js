const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(G),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(G),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":50,\"nextId\":50,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-f96e720e\",\"2\":\"v-f96e720e@0\",\"3\":\"v-0e0f1762\",\"4\":\"v-0e0f1762#前言\",\"5\":\"v-0e0f1762#什么是格\",\"6\":\"v-0e0f1762#格问题\",\"7\":\"v-0e0f1762#格应用\",\"8\":\"v-0e0f1762#哈希函数\",\"9\":\"v-0e0f1762#公钥密码\",\"10\":\"v-0e0f1762#格的性质\",\"11\":\"v-0e0f1762#格定义\",\"12\":\"v-0e0f1762#模体积-volume\",\"13\":\"v-0e0f1762#派生格\",\"14\":\"v-0e0f1762#gram-schmidt正交化\",\"15\":\"v-0e0f1762#再究格问题\",\"16\":\"v-0e0f1762#svp归约为cvp\",\"17\":\"v-0e0f1762#量化嵌入\",\"18\":\"v-0e0f1762#格基归约\",\"19\":\"v-0e0f1762#一些思路\",\"20\":\"v-0e0f1762#归约算法\",\"21\":\"v-0e0f1762#babai方法和bkz算法\",\"22\":\"v-0e0f1762#格基密码\",\"23\":\"v-0e0f1762#背包密码-knapsack\",\"24\":\"v-0e0f1762#ntru\",\"25\":\"v-0e0f1762#lwe\",\"26\":\"v-0e0f1762#svp因子测量\",\"27\":\"v-0e0f1762#后记\",\"28\":\"v-0e0f1762#reference\",\"29\":\"v-0e0f1762@0\",\"30\":\"v-0e0f1762@1\",\"31\":\"v-83d79bb4\",\"32\":\"v-83d79bb4#前言\",\"33\":\"v-83d79bb4#正文\",\"34\":\"v-83d79bb4#代码实现\",\"35\":\"v-83d79bb4#安全分析\",\"36\":\"v-83d79bb4#逆向extract-number函数\",\"37\":\"v-83d79bb4#预测随机数\",\"38\":\"v-83d79bb4#逆向twist函数\",\"39\":\"v-83d79bb4#逆向init函数\",\"40\":\"v-83d79bb4#扩展\",\"41\":\"v-83d79bb4#情况一\",\"42\":\"v-83d79bb4#情况二\",\"43\":\"v-83d79bb4#情况三\",\"44\":\"v-83d79bb4#参考\",\"45\":\"v-83d79bb4@0\",\"46\":\"v-83d79bb4@1\",\"47\":\"v-e1e3da16\",\"48\":\"v-e362e55c\",\"49\":\"v-52910e0a\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,2],\"2\":[null,null,1],\"3\":[1,3],\"4\":[1],\"5\":[1,45],\"6\":[1,43],\"7\":[1],\"8\":[1,9],\"9\":[1,70],\"10\":[1,3],\"11\":[1,120],\"12\":[3,37],\"13\":[1,100],\"14\":[2,9],\"15\":[1,3],\"16\":[1,57],\"17\":[1,33],\"18\":[1,83],\"19\":[1,44],\"20\":[1,22],\"21\":[1,41],\"22\":[1,4],\"23\":[3,60],\"24\":[1,52],\"25\":[1,5],\"26\":[1,7],\"27\":[1,16],\"28\":[1,241],\"29\":[null,null,1],\"30\":[null,null,1],\"31\":[1],\"32\":[1,3],\"33\":[1,35],\"34\":[1,51],\"35\":[1],\"36\":[2,63],\"37\":[1,11],\"38\":[1,75],\"39\":[1,50],\"40\":[1,99],\"41\":[1,28],\"42\":[1,21],\"43\":[1,51],\"44\":[1,3],\"45\":[null,null,1],\"46\":[null,null,2],\"47\":[1],\"48\":[1],\"49\":[4]},\"averageFieldLength\":[1.192536398467433,39.323384158260986,0.42415923129718597],\"storedFields\":{\"0\":{\"h\":\"关于我\"},\"1\":{\"h\":\"密码学\",\"t\":[\"一些学习笔记，以下是目录\"]},\"2\":{\"c\":[\"密码学\"]},\"3\":{\"h\":\"再探格密码\",\"t\":[\"关于格密码的学习从很久以前已经开始，本篇博文主要是从头梳理再做一次系统的记录。\"]},\"4\":{\"h\":\"前言\"},\"5\":{\"h\":\"什么是格\",\"t\":[\"我们可以这样定义格，它是一组向量在n维空间中有着周期性的点集，或者说对于n个线性无关的向量v1​,v2​,…,vn​∈Rn，这些向量的整系数组合构成的点集即为一个格，即\",\"L(v1​,v2​,…,vn​):={i=1∑n​αi​vi​​αi​∈Z}\",\"我们把v1​,v2​,…,vn​称为格L的一组基。\",\"Fig.1 一个R2中格的两组基\",\"从18世纪开始，拉格朗日、高斯和闵可夫斯基等数学家都对格有研究。不过我们主要是看格在密码学中的应用，1996年Ajtai发现格不仅可以用来分析密码还可以来构建密码，同时发现用格来构建密码体系的安全性基于格问题的最坏情况。所以只要解决了某一格密码体系，就可以解决基于此类格问题构建的任何密码（其他密码体系都是基于平均性假设）。\",\"上面这句话的意思就是在格密码体系中我们可以避免很多特殊要求，例如在RSA中，我们构建N时要避免选择一些特殊的因子（因为可能会让分解很容易，关于特殊因子导致的RSA分解例子太多了），所以此时我们相当于是一个黑名单机制，不断地选择因子，不断地发现一些因子“不好”，从而避免选择它们。而在格密码中，我们无须考虑这类问题，因为攻击同规格的格问题难度几乎一致。\",\"同时格密码还有下列优势\",\"涉及的计算简单，因为都是有限域运算。\",\"抗量子攻击，这很重要。\"]},\"6\":{\"h\":\"格问题\",\"t\":[\"SVP（最短向量问题）是格中最主要的问题。其内容为给定一个格基，找出格中的最短非零向量，在高维格中这是一个困难问题，所以我们更多关注它的变体，例如\",\"apprSVP（近似最短向量问题），找到近似最短非零向量si​，满足∥si​∥≤γ∥u∥，其中u代表格中其他任意向量。\",\"SIVP（最短线性无关向量问题），找到n个线性无关向量si​，满足∥si​∥≤Λn​(L)\",\"uSVP（唯一最短向量问题），找到最短非零向量si​，满足它比所有其他非平行最短向量短。\",\"CVP（最近向量问题），给定目标向量t∈Rn，找到格中非零向量si​，满足∥si​−t∥≤∥sj​−t∥，其中sj​代表格中其他非零向量。\",\"SVP的难度来自于格中有不同的基，现在我们经常使用的LLL算法难度近似为2O(n)，不过它在应用中总是很有效，只能说可能是LLL的界太松了，后续还有很多其他优化后的其他算法，但对于要求SVP的解还是需要2O(n)的运算时间。\",\"对于apprSVP，一般我们认为nc-apprSVP当c≥21​时非常困难，这里的nc为多项式因子，代表随着n的增大，算法所需时间将呈多项式增长。\"]},\"7\":{\"h\":\"格应用\"},\"8\":{\"h\":\"哈希函数\",\"t\":[\"Ajtai最初提出了一类单向函数 [2]，安全性基于nc-apprSVP的最坏难度，后续的工作都是来减少常数c来提高安全上限。\",\"上述内容都是利用格来构造哈希函数提高抗碰撞能力，因为这不是我的研究方向，故在此不做深究。\"]},\"9\":{\"h\":\"公钥密码\",\"t\":[\"Ajtai在上述的基础上又和Dwork构建了一个公钥密码体系，其安全性基于uSVP的最坏难度，这里我们只看一下改进后的该密码系统 [3]\",\"给定大整数N，选取私钥h∈[N​,2N​]，公钥为从0,1,…,N−1中选取m（m=O(logN)）个数a1​,…,am​，并且要求他们满足都接近N/h的整数倍，并且包含一个索引i0​∈[m]要求ai0​​接近N/h的奇数倍。\",\"加密时进行按位加密，对于比特0，将{a1​,…,am​}的随机子集求和并模N，对于比特1，则在求和时加上⌊ai0​​/2⌋。\",\"解密时则将w模N/h，如果余数很小则为0，否则为1。\",\"正确性证明：a1​,…,am​都接近N/h整数倍，所以任意子集之和也接近N/h整数倍，所以对于0的加密结果模N/h的余数很小，同理⌊ai0​​/2⌋不接近N/h整数倍，所以1的加密结果模N/h余数很大。\",\"安全性证明涉及到上述抗碰撞哈希函数的安全性证明，大致就是像格中添加足够的高斯噪音，得到一个接近均匀分布的分布，再从这个分布的统计距离来分析格问题的困难度，详细可参照 [1] 中第六节内容。\",\"很明显上述密码体系相对于如今的格密码体系效率非常之低，用n维的格就需要O(n4)大小的公钥，且每个加密比特都会变成O(n2)大小，显然不符合如今的加密系统需求。\",\"后续Regev提出了基于格基的LWE问题密码体系 [4]，关于LWE不会在本篇做过多介绍，后面可能我会写单独的博文，它基于SVP的最坏情况量子难度，也就是说破解该密码就能有高效的量子算法攻击apprSVP，不过注意上述两个密码系统安全性无法比较优劣，一是第一个基于uSVP而不是SVP，二是LWE显示出SVP可能有量子算法。不过目前还没有量子算法可以超越经典算法解决格问题，所以我们依然可以任务在量子情况下格问题也是困难的。\"]},\"10\":{\"h\":\"格的性质\",\"t\":[\"上面我们介绍了一些关于格的基本定义和历史工作，从这里开始我们将系统性学习格相关理论和性质。\"]},\"11\":{\"h\":\"格定义\",\"t\":[\"在群论中，我们通常将格定义为Rn的离散子群，它们的具体定义如下：\",\"离散性：设D是Rn的一个子集，当它没有聚点时，即任意x∈D，都存在r>0使得B(x,r)∩D={x}，其中B(x,r)={y∈Rn:∥x−y∥<r}，简单点说就是以该点为圆心半径为r的球内没有其他点。\",\"格：(Rn,+)的加法子群，如果它具有离散性则称为格\",\"关于格结构的抽象定义我们只了解到此，我们更关注计算上的内容。在前面我们已经描述了使用线性无关的向量组作为一组基来表示或者说生成格，对于基向量构成的矩阵B成为格的格基，则格的表示可以写为\",\"L(B):={Bx:x∈Zn}\",\"接下来我们来考虑格的秩，格的秩d即子空间span(L)的维度，注意格并不一定是满秩的，因为并不要求这组线性无关向量的个数是n，当且仅当d=n时格才是满秩的。\",\"还要注意的是，格基一定是构成子空间的一个极大无关向量组，但子空间的每个极大无关向量组不一定能构成格基。对于Rn中的秩为d的格，如果B=(b1​,…,bd​)是d个无关向量，当且仅当不存在非零格向量x∈L使得x∈P(B)时B为L的一组基。其中P(B)代表一组向量生成的最小线性子空间（parallelepiped span），或者说n维平行空间。\",\"P(B)={i=1∑m​λi​bi​:∣λi​∣<1}\",\"充分必要证明：因为B是格基，则每个向量都可以由B的整系数组合构成，也就是x=∑i=1d​λi​bi​,λi​∈Z，如果x∈P(B)，则∣λi​∣<1，此时只有格点即零向量在P(b)中。反之如果B不是格基，则格中存在非零向量x∈P(B)，因为此时x不是B的整系数线性组合，又因为B也是L中d个无关向量，span(L)=span(B)，所以x能被B表示（但系数不全是整数）,记\",\"x=i=1∑d​λi​bi​\",\"同时我们考虑对λi​取整，记\",\"x′=i=1∑d​⌊λi​⌋bi​\",\"因为x′是格向量组的整系数组合，所以定然有x′∈L，又因为L是一个加法子群，则他们的差也属于格L（封闭性），则有\",\"y=x−x′=i=1∑d​(λi​−⌊λi​⌋)bi​\",\"又因为0≤λ−⌊λi​⌋<1，所以y∈P(b)，并且y还不能是零向量，因为之前说了λi​不全是整数。引用一下 [5]中的例图，下图b1​,b2​虽然是Z2的极大线性无关组，但因为存在非零向量属于P(B)，所以B不能作为Z2的格基，其实也就是有些点无法被覆盖（整系数线性表示）到，如果上面的数学描述看不懂的话看图应该就很轻松了。\",\"b1​和b2​张成的格和Z2的区别\",\"实际上上面阐述的内容简单点理解就是不仅需要极大无关向量组，还需要这组向量是完备的，能够表示格中的其他任意向量。\",\"从这里我们还能得到一个性质就是一定可以从一组极大无关向量组b1​,…,bd​中找出一组格基，存在d×d的下三角矩阵(uij​∈Rd×d)能够构造向量组ci​=∑j=1i​uij​bj​使得(c1​,…,cd​)是L的一组基（因为下三角阵乘上B不改变线性无关性，所以总是能从中构造出一组基）。由此可以得出结论，Rn空间中的格一定至少有一组基。\"]},\"12\":{\"h\":\"模体积（Volume）\",\"t\":[\"对于秩为d的格L，一组格基为B=(b1​,…,bd​)，则\",\"vol(L)=Δ(b1​,…,bd​)1/2=det(BTB)​\",\"简单点说，格的模体积就是格基矩阵行列式的绝对值。对于格中的不同格基，都可以通过乘上一个行列式为±1的单位矩阵来进行变换，所以同一个格无论取哪一组格基，其vol(L)都不变，反过来说属于不同格的格基其vol(L)不相同。\",\"还有另一种定义模体积的方式，对于Rn中的满秩格L，有r>0\",\"vol(L)=r→∞lim​∣B(0,r)∩L∣Vr​​\",\"这里就是说记以格点为中心半径为r的n维球B(0,r)中的格点数为N(r)，n维球的体积是Vr​，根据测度理论，r足够大时，B(0,r)中的格点数近似等于其中的向量数，因此有上述模体积的定义。\"]},\"13\":{\"h\":\"派生格\",\"t\":[\"子格\",\"如果格L∈Rn的子集M⊂L且M也是格，则M称为L的子格。每个子格都是子群，同时每个具有离散性的子群也都是子格，当dim(M)=dim(L)是称为全秩子格（full-rank）。\",\"不同于子空间，子格和L能有相同的秩但不等于L，此时考虑商集L/M，其中的元素个数我们称为群指数（group index），记为[L:M]，对于全秩子格M来说，有\",\"vol(M)=vol(L)[L:M]\",\"不是全秩子格的秩严格小于d，所以群指数无限大，则没有上述关系。\",\"还有一个重要的子格关系为原始子格（primitive sublattice），对于秩为d的格L，当且仅当秩为k的子格M的基B可以通过添加d−k个向量扩充为原格的一个基，则称M为原始子格。\",\"投影格（Projected lattices）\",\"将格投影到某个子空间上形成投影格，当然投影时仍需保证结果是离散的。对于秩为d的格L，选取一个秩为r的原始子格M⊂L，定义投影πM​:=πspan(M)​为投影在包含M的最小子空间的正交补（orthogonal complement）上，则πM​(L)∈Rn是一个秩为d−r的投影格，且模体积为vol(L)/vol(M)。\",\"这里还有关于投影格得到降秩的推论，不过此类内容还是遇到投影格的应用再写吧。\",\"对偶格（Dual lattice）\",\"一个格的每个元素都能视作另一个格的元素，对于格L，对偶格L×为\",\"L×={y∈span(L):⟨x,y⟩∈Z∣x∈L}\",\"如果L满秩，设B是格L的基，任何格向量都可以写成x=Bx′,x′∈Zn。相反Zn中的每个x′都能变成一个格向量，对于对偶向量y，则\",\"⟨x,y⟩=⟨Bx′,y⟩=⟨x′,BTy⟩∈Z\",\"即内积⟨x,y⟩为整数。此时考虑x′为单位向量，显然可以得到分量BTy也是整数，所以y′=BTy是一个整数向量，等价于对于y=(BT)−1y′，有L×⊆{(BT)−1y′∣y′∈Zn}。即每个y′也能得到一组对偶向量，即\",\"⟨x′,y′⟩=⟨x′,(BT)(BT)−1y′⟩=⟨Bx′,(BT)−1y′⟩=⟨x,y⟩\",\"对偶格的模体积为vol(L)−1，在对偶格中，可以把问题转化为另一种形式来简化问题进行求解，在格攻击的例子中或许我会写道对偶格的用法。\",\"其中还有一类特殊的格与正交格很相似，称为正交格（orthogonal lattice），对于不满秩的整格L，正交格定义为\",\"L⊥={y∈Rn:⟨x,y⟩=0∣x∈L}\"]},\"14\":{\"h\":\"Gram Schmidt正交化\",\"t\":[\"这个理论上在学线代的时候就都学过了，这里就不再记录分享了。简单来说就是将向量组变成正交向量组的一种方法，因为后续会提到GSO（Gram Schmidt Orthogonalization）向量这里写一下。\"]},\"15\":{\"h\":\"再究格问题\",\"t\":[\"之前我们已经介绍过格问题的定义，这里我们将深入讲解这些问题之间的联系以及如何解决它们。\"]},\"16\":{\"h\":\"SVP归约为CVP\",\"t\":[\"一般我们认为同维度下CVP比SVP更难，如果解决了CVP都能解决相应的SVP，因为SVP可以按照下列方法转为CVP求解。\",\"设格基为B=[b1​,…,bd​]，定义格基B(j)=[b1​,…,bj​−1,2bj​,bj+1​,…,bd​]，此时假设有个CVP预言机，给定(B(j),bj​)代表格基为B(j)目标向量为bj​求解CVP，返回为vj​，对所有的1≤j≤d 都做这个操作，最后我们可以得到v1​−b1​,…,vd​−bd​便是格L(B)的最短向量。\",\"这个思路非常巧妙，显然vi​是格中的向量，由于封闭性vi​−bi​也是格中向量，又由于它们两两非常接近，很大概率它们就是SVP的解。证明如下\",\"对于u=∑λi​bi​是格的最短非零向量，则至少存在一个λi​为奇数\",\"考虑v=u+bj​是格L(B(j))中向量（显然）且二者距离dist(v,bj​)=∥u∥\",\"构造v=λj​(2bj​)+∑i=j​λi​bi​符合上述要求且是格中向量。\",\"考虑u=v−bj​=(2λj​−1)bj​+∑i=j​λi​bi​−bj​是L(B)的最短向量，因为根据(1)得至少存在一个奇系数。根据(2)有对于参数(B(j),bj​)CVP的解v要满足到bj​的距离不能超过dist(v,bj​)=∥u∥，而最短向量长度等于这个距离差值，也就代表在所有的参数(B(j),bj​)CVP的解中至少有一个解是SVP的解。上述三个命题的证明就不再说了，详细证明可见 [5]\"]},\"17\":{\"h\":\"量化嵌入\",\"t\":[\"同理我们还可以考虑是否有方法将CVP转化为SVP，存在一种启发式方法利用嵌入技术（Embedding technique）将CVP转化为SVP，由Goldreich、Goldwasser和Halevi在1997年提出，详见 [7]\",\"对于格L(B)，其中格基B=[b1​,…,bn​]，对于CVP的目标向量为c，则我们可以构造\",\"B′=​∣c∣1​∣b1​∣0​⋯…​∣bn​∣0​​\",\"显然B′行列式与B相同，所以L(B′)的模体积也与L相同。我们考虑上述CVP的解为x=∑λi​bi​，则此时(c−x,1)（因为L(B′)秩是n+1）便是L(B′)的SVP解，反过来找到了这个格的SVP解便可以得到对于格L、目标项链为c的CVP解。\"]},\"18\":{\"h\":\"格基归约\",\"t\":[\"格基归约的目的是为了找到最短向量，1982年，Lenstra、Lenstra和Lov´asz发表了Lenstra-Lenstra-Lov´asz算法（LLL），这是一种基于Hermite不等式的格子基底缩减算法，能够找到一个近似最短非零向量的短向量。在了解下面的解决问题方法前我们需要先阐述一些定义和理论。\",\"第i小向量模长：对于秩为d的格L，定义第i小向量模长λi​(L)为\",\"λi​(L)=u1​,…,ui​∈Lmin​1≤j≤imax​∥uj​∥\",\"其中u1​,…,ui​线性无关，也就是取最长向量的第i个最小值。此时得到的序列{λi​}是非递减的，因为可能有多个无关向量同时取最小值。而我们要做的就是找到这样的格基使得整个序列全局最小，这样我们便可以取解决一些列最短向量问题。\",\"但是有些时候这些无关向量并不一定是格基，且对于高维格，同时达到最小值得基可能不一定存在，所以此时我们还需要使用不同的方法来确定格中最小向量长度。\",\"之前我们使用测度理论定义了格的模体积，我们去掉极限号，将等式变为\",\"vol(L)Vr​​≈∣B(0,r)∩L∣\",\"此时我们可以用很巧妙的方法来找到最短向量，对于最短向量，也就意味着以最短向量模长为半径的n维球体内只包含一个向量，即等式的右边取值为1，则此时我们可以使用斯特林公式去近似n维球体积中参数（这里涉及n维球体积公式，在此不做介绍）来得到半径的近似解\",\"r≈2πen​​(vol(L))1/n\",\"由此我们可以得到一种新的方式定义格L中最短向量长度的定义\",\"σ(L)=2πen​​(vol(L))1/n\",\"这很cool，意味着我们终于能够知道要找的最短模长是多长了，不过不好的消息的上述内容是高斯启发（Gaussian Heuristic），因为我们是“期望”格L在C∈Rn的数量L∩C是vol(C)/vol(L)，但很多时候所构造的格并不满足这一特征，所以我们需要继续了解其他人的工作。\",\"Hermite首次证明了最短向量模长的上界，在他的原始工作研究基于格的二次型，中定义了Hermite常数γd​是所有秩为d的格中λ1​(L)2/vol(L)2/d，由此可以得到最短向量模长上界为\",\"λi​(L)≤γd​​vol(L)1/d\",\"不过这又引出了新的问题，γd​的值是多少，实际上在高维格中求γd​的值也是一个困难问题，但Hermite给出了Hermite不等式证明了γd​的上界\",\"Hermite不等式：γd​≤γ2d−1​，对于d≥2时，γ2​=4/3​。证明详见 [6]\",\"后续基于Minkowski凸体的定理还可以得到关于γd​的线性上下界，在此不在一一介绍，\"]},\"19\":{\"h\":\"一些思路\",\"t\":[\"Size-reduction\",\"不适用特殊情况，不过后续会用到这里的内容，还是在这里写一下\",\"一组基当GSO-投影系数满足∣μij​≤1/2∣时称为size-reduced\",\"Gauss-reduction\",\"在18世纪末，Lagrange和Gauss都发明了一种将秩为2的格基二次型归约算法。 它包含如下步骤\",\"选取两个基向量b1​,b2​，若⟨b1​,b2​⟩=0，则进行正交化得到正交向量。\",\"对上述得到的正交向量进行单位化，作为格的新格基\",\"（学过线代的应该对这一套流程非常熟悉）\",\"HKZ-reduction（Hermite-Korkine-Zolotarev-reduce）\",\"对于一组基当满足size-reduced的基础且∥bi∗​∥=λi​(πi​(L))时称为HKZ-reduced，其中bi∗​代表bi​的GSO-投影\",\"然后我们可以得到如下结论\",\"i+34​≤(λi​(L)∥bi​∥​)2≤4i+3​\",\"上述不等式的上下界分别由可见 [8]，[9]。最后这些HKZ归约得到的bi∗​便是新格基。\"]},\"20\":{\"h\":\"归约算法\",\"t\":[\"上述思路部分的算法我们就不再介绍了，这里我们主要介绍今天常用的LLL算法。\",\"对于格基[b1​,…,bd​]，当因子δ∈(41​,1)且能size-reduced且满足\",\"δ∥bi∗​∥2≤∥bi+1∗​+μi+1,i​bi∗​∥2\",\"时称为LLL-reduced，这个不等式也叫做Lovász条件。\",\"LLL算法\",\"其实也就是不断地进行GSO，然后将替换符合Lovász条件的向量继续GSO。LLL算法是一个多项式时间复杂度的算法，由于它的出现，后续有了非常多基于格归约的密码攻击方法。\"]},\"21\":{\"h\":\"Babai方法和BKZ算法\",\"t\":[\"Babai在1986年发表了两种求解CVP近似解的方法，可以将LLL应用于给定的格基来减少基向量模长从而得到CVP的解。详细可见Babai原始论文 [10]。\",\"对于格基B，目标向量为c的CVP，Babai具体操作为\",\"对格基进行LLL得到新的格基B′\",\"找到线性组合满足w=∑λi​bi′​最接近c\",\"将线性组合系数取整得到{λi′​}\",\"返回结果v=∑λi′​bi′​即为CVP的一个近似解。\",\"后续Schnorr在Babai等的基础上提出了BKZ归约算法（Block-Korkine-Zolotarev reduction），它主要工作便是在HKZ和LLL中进行折中选择，增加运行时间提高解的精度。\",\"对于一组格基[b1​,…,bd​]，系数2≤β≤d，当可size-reduced且满足\",\"δ∥bi∗​∥2≤λ1​(πi​(L(b1​,…,bmin(i+β−1,d)​)))2\",\"时称为BKZ-reduced，便可以以此得到一组新的格基，具体算法如下。\",\"BKZ格归约算法\"]},\"22\":{\"h\":\"格基密码\",\"t\":[\"下面内容主要展示一些利用格基归约来攻击这些密码算法的方式，以及其中关于分析模长和配平的一些操作。关于每种密码的详细介绍可能会开新的博文单独撰写。\"]},\"23\":{\"h\":\"背包密码（Knapsack）\",\"t\":[\"这里只对背包密码算法做一个简单的介绍\",\"私钥为一个超递增序列{an​}，满足ai​>∑k=1i−1​ak​，模数m，满足m>∑i=1n​ai​，乘数w，满足gcd(w,m)=1。\",\"公钥为{bi​}，满足bi​≡wai​(modm)\",\"加密：设明文为{vi​},vi​∈{0,1}，则密文\",\"c≡i=1∑n​bi​vi​(modm)\",\"解密：明文为\",\"v=w−1c≡i=1∑n​vi​ai​(modm)\",\"可以构造格\",\"L=​100⋮00​010⋮00​001⋮00​⋯⋯⋯⋱⋯⋯​000⋮10​b1​b2​b2​⋮bn​−c​​\",\"其中v=(v1​,v2​,…,vn​,0)是一个格点，接下来要做的便是证明它是最短非零向量，这样我们才可以用LLL求解得到。\",\"显然这个格的模体积vol(L)=c，则有\",\"σ(L(B))≥2πen​​c1/(n+1)\",\"也就是只要∥v∥≤σ(L(B))，说明我们构造的v便是SVP的解（或者说近似解），而在01背包中∥v∥≈n/2​，也就是当πe1​c1/(n+1)≥1时便很大概率可以通过LLL找到这组解，但是到此我们的分析并没有那么精确，关于这里具体取何值能够攻击成功可以参考 [12]。\",\"对于背包密码的工作不止于此，后续Coster、Joux等人还在这个格的基础上再次优化，提高了攻击上限，详情可见 [13]。\"]},\"24\":{\"h\":\"NTRU\",\"t\":[\"关于NTRU的详细介绍可见 [14]，它是一种安全性基于多项式环上的SVP构造的公钥密码体系，目前也是后量子密码的热点算法，因为其相比其他后量子公钥密码速度很快。\",\"一维NTRU\",\"这里直接引用的是 [15]中对NTRU介绍的例子，生成了一个一维NTRU公私钥。显然可以构造格\",\"L=(10​hq​)\",\"则有格点v=(f,g)，模长为f2+g2​<q​，显然这里的最短向量期望为\",\"σ(L)=vol(L)1/2=q​\",\"所以我们可以认为v就是SVP的解或近似解，从而可以通过LLL得到私钥。不过实际上我们在攻击时目标可能并不完全符合密码标准或者说是一类自定义的密码体系，例如对于这个例子，如果我们让f的值变得更大，就会导致∥v∥>σ(L)，从而不一定能够从LLL得到解，所以很多时候在实际攻击时我们需要对构造的格进行配平。\",\"所谓配平，核心就是在不影响格点关系的情况下增大格的模体积，使得最短向量期望值变得更大，从而让我们想要的目标向量变成SVP的解或近似解，我们可以给原格点较小的一列乘上一个数D，例如现在是\",\"(f,−k)L=(f,g)\",\"则我们变成\",\"(f,−k)(10​DhDq​)=(f,Dg)\",\"此时我们的目标向量变成(f,Dg)，而D的取值和f与g的插值有关，一般来说我们的目的就是让向量在每个方向的长度都一致，即变得“更平”。因为对于最短向量来说，某列乘上一个数对模长的影响是累加的，而对格模体积的影响是累乘的，这样我们就可以在原做法的基础上得到一个更大的解的上界。\"]},\"25\":{\"h\":\"LWE\",\"t\":[\"本想是在这里写LWE的简单介绍以及上述关于SVP、CVP问题相互转换的实际应用在格攻击LWE密码算法中的体现，不过写的时候发现干脆和RLWE一起介绍。所以准备等介绍格在多项式中应用时再来讲这些内容吧。\"]},\"26\":{\"h\":\"SVP因子测量\",\"t\":[\"鸽了，现在还停留在应用层面，之后如果涉及到要进行问题难度分析在来写这个吧，以及前面提到的“添加足够的高斯噪音”分析困难度的内容。\"]},\"27\":{\"h\":\"后记\",\"t\":[\"本篇博客本只写了“前言”部分的内容，写完再回顾发现很多内容并没有说清楚，故干脆将那些内容作为“前言”部分进行普及格知识以及发展历史，后续从格的性质开始介绍格的各种属性以及各类问题的解决方式。最后讲了一点实际的攻击例子。\",\"作为新博客的第一篇博文，顺便在这里提及一下关于“密码学”栏目的构成，在这里我不会写太多CTF中实际题目的应用及代码，更多的是从历史论文中学习各类知识的历史的本质。关于CTF中的密码题目我可能会新开一个栏目专门只写题目WP。\"]},\"28\":{\"h\":\"Reference\",\"t\":[\"[1] Regev O. Lattice-based cryptography[C]//Annual International Cryptology Conference. Berlin, Heidelberg: Springer Berlin Heidelberg, 2006: 131-141.\",\"[2] Ajtai, M.: Generating hard instances of lattice problems. In: Proc. 28th ACM Symp. on Theory of Computing. (1996) 99–108 Available from ECCC at http://www.uni-trier.de/eccc/.\",\"[3] Regev, O.: New lattice-based cryptographic constructions. Journal of the ACM 51(6) (2004) 899–942 Preliminary version in STOC’03.\",\"[4] Regev, O.: On lattices, learning with errors, random linear codes, and cryptography. In: Proc. 37th ACM Symp. on Theory of Computing (STOC). (2005) 84–93\",\"[5] van de Pol J. Lattice-based cryptography[J]. Eindhoven University of Technology, Department of Mathematics and Computer Science, 2011.\",\"[6] C. Hermite. Extraits de lettres de M. Ch. Hermite a M. Jacobi sur differents objets de la th´eorie des nombres, Deuxi`eme lettre du 6 aoˆut 1845. J. Reine Angew. Math, 40:279–290, 1850.\",\"[7] O. Goldreich, S. Goldwasser, and S. Halevi. Public-key cryptosystems from lattice reduction problems. In B. Kaliski, editor, Advances in Cryptology - CRYPTO’97, volume 1294 of Lecture Notes in Computer Science, pages 112–131. Springer Berlin / Heidelberg, 1997.\",\"[8] K. Mahler. A theorem on inhomogeneous diophantine inequalities. In Nederl. Akad. Wetensch., Proc, volume 41, pages 634–637, 1938\",\"[9] J.C. Lagarias, H.W. Lenstra, and C.P. Schnorr. Korkin-zolotarev bases and successive minima of a lattice and its reciprocal lattice. Combinatorica, 10(4):333–348, 1990.\",\"[10] L. Babai. On Lovász lattice reduction and the nearest lattice point problem. Combinatorica, 6(1):1–13, 1986.\",\"[11] C.P. Schnorr. A hierarchy of polynomial time lattice basis reduction algorithms. Theoretical computer science, 53(2-3):201–224, 1987\",\"[12] J.C. Lagarias and A.M. Odlyzko. Solving low-density subset sum problems. J. ACM, 32(1):229–246, 1985.\",\"[13] M.J. Coster, A. Joux, B.A. LaMacchia, A.M. Odlyzko, C.P. Schnorr, and J. Stern. Improved low-density subset sum algorithms. Computational Complexity, 2(2):111–128, 1992.\",\"[14] Hoffstein, J., Pipher, J., Silverman, J.H.: NTRU: a ring-based public key cryptosystem. In: Algorithmic number theory (ANTS). Volume 1423 of Lecture Notes in Comput. Sci. Springer (1998) 267–288\",\"[15] Hoffstein J, Pipher J, Silverman J H, et al. An Introduction to Cryptography[M]. Springer New York, 2014.\"]},\"29\":{\"c\":[\"密码学\"]},\"30\":{\"c\":[\"Lattice\"]},\"31\":{\"h\":\"MT19937分析\"},\"32\":{\"h\":\"前言\",\"t\":[\"本内容是2022发在cryptography-wiki上的文章了，现在转回到blog上\"]},\"33\":{\"h\":\"正文\",\"t\":[\"MT19937即梅森旋转算法（Mersenne twister）由松本眞（日语：松本真）和西村拓士在1997年开发，基于二进制有限域F2​上的矩阵线性递归，可以快速产生高质量的伪随机数。\",\"该算法的周期为219937−1，故名为MT19937。该算法具有以下优点\",\"周期非常长，为219937−1\",\"在1≤k≤623都满足k-分布\",\"能比硬件实现的方法更快产生随机数\",\"k-分布：一个周期为P的w位整数的伪随机数序列xi​，如果下列成立则称其v-比特精度的k-分布成立。\",\"令truncv​(x)表示由x的前v位形成的数，并考虑P中k个v位向量。\",\"(truncv​(xi​),truncv​(xi+1​),…,truncv​(xi+k−1​))(0≤i<P)\",\"然后，2kv个组合中每一个都在一个周期内出现次数相同（全0组合出现次数较少除外）。\"]},\"34\":{\"h\":\"代码实现\",\"t\":[\"MT19937算法可分为三个部分\",\"初始化\",\"旋转状态\",\"提取伪随机数\",\"其中32位的MT19937 Python代码实现为：\",\"def _int32(x): return int(0xFFFFFFFF & x) class MT19937: # 初始化 def __init__(self, seed): self.mt = [0] * 624 self.mt[0] = seed self.mti = 0 for i in range(1, 624): self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] >> 30) + i) # 提取伪随机数 def extract_number(self): if self.mti == 0: self.twist() y = self.mt[self.mti] y = y ^ y >> 11 y = y ^ y << 7 & 2636928640 y = y ^ y << 15 & 4022730752 y = y ^ y >> 18 self.mti = (self.mti + 1) % 624 return _int32(y) # 旋转状态 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] & 0x80000000) + (self.mt[(i + 1) % 624] & 0x7fffffff)) self.mt[i] = (y >> 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df \"]},\"35\":{\"h\":\"安全分析\"},\"36\":{\"h\":\"逆向extract_number函数\",\"t\":[\"对于extract_number函数，可以发现就是将状态中的数据进行位运算后给出。\",\"显然我们可以发现这里的四次位运算类似，我们以y = y ^ y << 7 & 2636928640为例来进行逆向处理。\",\"为了方便描述，我们将代码改为y = x ^ ((x << 7) & 2636928640)，其中y可以看作已知，x未知。\",\"xx<<72636928640y​→aaaabbbbccccddddeeeeffffgggghhhh⊕→bccccddddeeeeffffgggghhhh0000000&→10011101001011000101011010000000=→naannnbnccncnnddenenfnnfnggghhhh​\",\"这里为了方便编写便使用相同的字母作为一段，实际上其值可能不同。\",\"显然我们可以发现y的低7位就是x的低7位和2636928640的低7位异或的结果。且2636928640低7位为0，所以y的低7位就是x的低7位。即我们能够得到ggghhhh的结果，基于此，我们便可以向前恢复得到eeffffg。\",\"eeffffg=(ggghhhh&0101101)⊕enfnnfn\",\"同理可以向前恢复得到x的所有值。完整Python代码实现为\",\"o = 3989032602 def inverse_right_mask(res, shift, mask=0xffffffff, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp >> shift & mask return tmp def inverse_left_mask(res, shift, mask=0xffffffff, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp << shift & mask return tmp def extract_number(y): y = y ^ y >> 11 y = y ^ y << 7 & 2636928640 y = y ^ y << 15 & 4022730752 y = y ^ y >> 18 return y&0xffffffff def recover(y): y = inverse_right_mask(y,18) y = inverse_left_mask(y,15,4022730752) y = inverse_left_mask(y,7,2636928640) y = inverse_right_mask(y,11) return y&0xffffffff print(recover(extract_number(o)) == o) \"]},\"37\":{\"h\":\"预测随机数\",\"t\":[\"当我们能够逆向extract_number中的数据时，这也意味着我们能够提取得到state中的原始数据，同时可以发现后续的随机数完全依赖于上一轮的state，所以如果我们能够得到某一轮的全部state数据，便可以向后调用twist来预测随机数。\",\"此类题型在CTF中经常出现，部分题型没有明确的给出随机数信息，但可以泄漏的其他信息得到随机数，解题时可以考虑加以注意是否能够直接或间接的得到题目中的随机数信息。\"]},\"38\":{\"h\":\"逆向twist函数\",\"t\":[\"在上文中我们提到如果得到了某一轮state的全部信息便可以向后预测随机数，那么如果我们需要向前恢复随机数，则需要对twist函数进行逆向。\",\"y→y≫1→⊕0x9908b0df→=⊕si+397​==out=​aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaux0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaau10011001000010001011000011011111bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccccccccccccvdddddddddddddddddddddddddddddddd​\",\"其中y = state[i] & 0x80000000 | state[i + 1] & 0x7fffffff，我们可以发现新的值只和si​,si+1​,si+397​有关，在上面的两次异或中，第一次异或和y的奇偶性来确定\",\"由于y≫1的最高位必定为0，此时我们可以列出下列关系表，\",\"0\",\"1\",\"0\",\"N\",\"Y\",\"1\",\"Y\",\"N\",\"其中行为最终输出out的最高位值，列为si+397​的最高位值，单元值代表是否发生第一次异或。由此通过判断是否发生异或，可以得到y的最低位值。\",\"此时按照extract_number中一样的方法，我们有\",\"u=d⊕v⊕x,oru=d⊕v⊕x⊕1\",\"同理，我们便可以向前恢复得到y的所有值。\",\"同时y的值即为si​的最高位和si+1​的第[2, 32]位。同时我们可以对si+1​和si+2​生成的y值做同样操作得到同样si+1​的最高位，对si−1​和si​生成的y值做同样操作得到si​的第[2, 32]位，至此原state恢复完成。\",\"Python代码实现为：\",\"def inv_twist(state): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df def recover(i): y = state[i + 624] ^ state[i + 397] if y & high == high: # 异或了常数 y ^= mask y <<= 1 y |= 1 else: # 没有异或常数 y <<= 1 return y for i in range(len(state)-625, -1, -1): # 得到s_i的最高位 state[i] = recover(i) & high # 对s_{i-1}做同样操作得到2-32位 state[i] |= recover(i-1) & low return state \"]},\"39\":{\"h\":\"逆向init函数\",\"t\":[\"我们可以发现第一轮的初始状态是通过seed生成的。\",\"关键操作为\",\"self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] >> 30) + i) \",\"显然这里的加法和乘法都存在逆运算，而中间的mti−1​⊕(mti−1​≫30)可以通过上文所述方法进行逆运算。\",\"from gmpy2 import invert def _int32(x): return int(0xFFFFFFFF & x) def init(seed): mt = [0] * 624 mt[0] = seed for i in range(1, 624): mt[i] = _int32(1812433253 * (mt[i - 1] ^ mt[i - 1] >> 30) + i) return mt seed = 3989032602 def invert_right(res,shift): tmp = res for i in range(32//shift): res = tmp^res>>shift return _int32(res) def recover(last): n = 1<<32 inv = invert(1812433253,n) for i in range(623,0,-1): last = ((last-i)*inv)%n last = invert_right(last,30) return last state = init(seed) print(recover(state[-1]) == seed) \"]},\"40\":{\"h\":\"扩展\",\"t\":[\"在上文中我们介绍了对于MT19937各个函数的逆向分析以及算法实现，但其中我们针对的都是以32bit为一组，并且能够获取到足够多连续随机数值的情况，那么如果我们得到的并不是连续的随机数此时我们该做何分析。\",\"以Python中的random实现的getrandbits为例。\",\"// getrandbits(k) -> x. Generates an int with k random bits. static PyObject * _random_Random_getrandbits_impl(RandomObject *self, int k) /*[clinic end generated code: output=b402f82a2158887f input=8c0e6396dd176fc0]*/ { int i, words; uint32_t r; uint32_t *wordarray; PyObject *result; if (k < 0) { PyErr_SetString(PyExc_ValueError, \\\"number of bits must be non-negative\\\"); return NULL; } if (k == 0) return PyLong_FromLong(0); if (k <= 32) /* Fast path */ return PyLong_FromUnsignedLong(genrand_uint32(self) >> (32 - k)); words = (k - 1) / 32 + 1; wordarray = (uint32_t *)PyMem_Malloc(words * 4); if (wordarray == NULL) { PyErr_NoMemory(); return NULL; } /* Fill-out bits of long integer, by 32-bit words, from least significant to most significant. */ #if PY_LITTLE_ENDIAN for (i = 0; i < words; i++, k -= 32) #else for (i = words - 1; i >= 0; i--, k -= 32) #endif { r = genrand_uint32(self); if (k < 32) r >>= (32 - k); /* Drop least significant bits */ wordarray[i] = r; } result = _PyLong_FromByteArray((unsigned char *)wordarray, words * 4, PY_LITTLE_ENDIAN, 0 /* unsigned */); PyMem_Free(wordarray); return result; } \",\"可以发现，当参数为0时，返回0，当参数小于32时，生成一个32位的随机数取其高位，当参数大于32时，生成多个随机数进行拼接。我们不妨考虑一些最极端的情况\"]},\"41\":{\"h\":\"情况一\",\"t\":[\"考虑我们不能获取连续的32bit随机数，只能隔1个取1个，考虑此时恢复随机数。\",\"显然这对我们来说没有太多影响，因为si+624​只和si​,si+1​,si+397​有关。假设此时i为偶数，且我们只取第奇数位数，则我们可以得到si+1​,si+397​。\",\"y→y≫1→⊕0x9908b0df→=⊕si+397​==out=​aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaux0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaau10011001000010001011000011011111bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbvccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddd​\",\"此时我们可以得到y的[2-32]位，则可以由此得到si+624​的第1和第[3-32]位。同时又有第2位的约束\",\"{a⊕c=d​\",\"显然这是一个较强的约束，因为si+624​中的错误会扩散至si​,si+624−397​,si+624−1​,...\",\"而此时我们能够所有第奇数个数的值和第偶数个数的1,3−32位值。故我们可以得到si+624​以及si​的全部信息。\"]},\"42\":{\"h\":\"情况二\",\"t\":[\"考虑我们现在只能获取所有第偶数个数的情况，此时显然我们只能够获取si+397​的第2位。但是si+397​的第二位配合si+397+1​，我们便能知道\",\"y = _int32((self.mt[i+397] & 0x80000000) + (self.mt[(i+397+1) % 624] & 0x7fffffff))\",\"的全部信息，此时再异或si+397+397​便可以得到si+397+624​的所有信息。最终通过此信息我们便能向前回推出sj​(1≤j)的所有信息。\"]},\"43\":{\"h\":\"情况三\",\"t\":[\"现在我们考虑一种更加极端的情况，假设我们只能获取每个随机数的第k位比特信息。我们是否还能利用扩散得到足够多的约束信息。\",\"这里我们可以回顾之前的内容，我们的本质是通过已知信息推出与之直接关联的未知信息，再利用已知信息和未知信息之间的约束条件进行扩散，因为我们有足够多的信息，我们总是能够利用足够多的约束来求解所有信息。\",\"对于这种情况，我们来考虑MT19937在F2​上的表现形式。\",\"设state[i]的二进制表示为：\",\"x={x0​,x1​,…,x30​,x31​}\",\"输出output的二进制表示位：\",\"z={z0​,z1​,…,z30​,z31​}\",\"我们有\",\"z0​=z1​=z2​=z3​=z4​=z5​=z6​=z7​=z8​=z9​=z10​=z11​=z12​=z13​=z14​=z15​=z16​=z17​=z18​=z19​=z20​=z21​=z22​=z23​=z24​=z25​=z26​=z27​=z28​=z29​=z30​=z31​=​x0​⊕x4​⊕x7​⊕x15​x1​⊕x5​⊕x16​x2​⊕x6​⊕x13​⊕x17​⊕x24​x3​⊕x10​x0​⊕x4​⊕x8​⊕x11​⊕x15​⊕x19​⊕x26​x1​⊕x5​⊕x9​⊕x12​⊕x20​x6​⊕x10​⊕x17​⊕x21​⊕x28​x3​⊕x7​⊕x11​⊕x14​⊕x18​⊕x22​⊕x29​x8​⊕x12​⊕x23​x9​⊕x13​⊕x20​⊕x24​⊕x31​x6​⊕x10​⊕x17​x0​⊕x11​x1​⊕x8​⊕x12​⊕x19​x2​⊕x9​⊕x13​⊕x17​⊕x20​⊕x28​x3​⊕x14​⊕x18​⊕x29​x4​⊕x15​x5​⊕x16​x6​⊕x13​⊕x17​⊕x24​x0​⊕x4​⊕x15​⊕x18​x1​⊕x5​⊕x8​⊕x15​⊕x16​⊕x19​⊕x26​x2​⊕x6​⊕x9​⊕x13​⊕x17​⊕x20​⊕x24​x3​⊕x17​⊕x21​⊕x28​x0​⊕x4​⊕x8​⊕x15​⊕x18​⊕x19​⊕x22​⊕x26​⊕x29​x1​⊕x5​⊕x9​⊕x20​⊕x23​x6​⊕x10​⊕x13​⊕x17​⊕x20​⊕x21​⊕x24​⊕x28​⊕x31​x3​⊕x7​⊕x11​⊕x18​⊕x22​⊕x25​⊕x29​x8​⊕x12​⊕x15​⊕x23​⊕x26​x9​⊕x13​⊕x16​⊕x20​⊕x24​⊕x27​⊕x31​x6​⊕x10​⊕x28​x0​⊕x11​⊕x18​⊕x29​x1​⊕x8​⊕x12​⊕x30​x2​⊕x9​⊕x13​⊕x17​⊕x28​⊕x31​​\",\"显然我们可以构造一个F232​方阵T满足\",\"x⋅T=z\",\"对于如何构造这个方阵有很多方式，在[1]中使用了一种选择乘数的方式得到T的每一行。\",\"现在我们把这种表示扩展到更高位空间，对于MT19937中的某一轮，其state可以表示为\",\"x={x0​,x1​,…,x19966​,x19967​}\",\"此时如果我们能获取每个随机数的第k位比特，则我们可以得到\",\"s={zi+k​}\",\"若我们能够获取足够多的数据，则可以构造\",\"s={s0​,s1​,s19966​,s19967​}\",\"同时构造\",\"x⋅T=s\",\"最后在GF2上求解这个代数方程即可。\"]},\"44\":{\"h\":\"参考\",\"t\":[\"[1]. 浅析MT19937伪随机数生成算法\"]},\"45\":{\"c\":[\"密码学\"]},\"46\":{\"c\":[\"PRNG\",\"MT19937\"]},\"47\":{\"h\":\"Posts\"},\"48\":{\"h\":\"Lattice\"},\"49\":{\"h\":\"P R N G\"}},\"dirtCount\":0,\"index\":[[\"浅析mt19937伪随机数生成算法\",{\"1\":{\"44\":1}}],[\"参考\",{\"0\":{\"44\":1}}],[\"zi+k​\",{\"1\":{\"43\":1}}],[\"z31​\",{\"1\":{\"43\":1}}],[\"z30​\",{\"1\":{\"43\":1}}],[\"z1​\",{\"1\":{\"43\":1}}],[\"z0​=z1​=z2​=z3​=z4​=z5​=z6​=z7​=z8​=z9​=z10​=z11​=z12​=z13​=z14​=z15​=z16​=z17​=z18​=z19​=z20​=z21​=z22​=z23​=z24​=z25​=z26​=z27​=z28​=z29​=z30​=z31​=​x0​⊕x4​⊕x7​⊕x15​x1​⊕x5​⊕x16​x2​⊕x6​⊕x13​⊕x17​⊕x24​x3​⊕x10​x0​⊕x4​⊕x8​⊕x11​⊕x15​⊕x19​⊕x26​x1​⊕x5​⊕x9​⊕x12​⊕x20​x6​⊕x10​⊕x17​⊕x21​⊕x28​x3​⊕x7​⊕x11​⊕x14​⊕x18​⊕x22​⊕x29​x8​⊕x12​⊕x23​x9​⊕x13​⊕x20​⊕x24​⊕x31​x6​⊕x10​⊕x17​x0​⊕x11​x1​⊕x8​⊕x12​⊕x19​x2​⊕x9​⊕x13​⊕x17​⊕x20​⊕x28​x3​⊕x14​⊕x18​⊕x29​x4​⊕x15​x5​⊕x16​x6​⊕x13​⊕x17​⊕x24​x0​⊕x4​⊕x15​⊕x18​x1​⊕x5​⊕x8​⊕x15​⊕x16​⊕x19​⊕x26​x2​⊕x6​⊕x9​⊕x13​⊕x17​⊕x20​⊕x24​x3​⊕x17​⊕x21​⊕x28​x0​⊕x4​⊕x8​⊕x15​⊕x18​⊕x19​⊕x22​⊕x26​⊕x29​x1​⊕x5​⊕x9​⊕x20​⊕x23​x6​⊕x10​⊕x13​⊕x17​⊕x20​⊕x21​⊕x24​⊕x28​⊕x31​x3​⊕x7​⊕x11​⊕x18​⊕x22​⊕x25​⊕x29​x8​⊕x12​⊕x15​⊕x23​⊕x26​x9​⊕x13​⊕x16​⊕x20​⊕x24​⊕x27​⊕x31​x6​⊕x10​⊕x28​x0​⊕x11​⊕x18​⊕x29​x1​⊕x8​⊕x12​⊕x30​x2​⊕x9​⊕x13​⊕x17​⊕x28​⊕x31​​\",{\"1\":{\"43\":1}}],[\"z0​\",{\"1\":{\"43\":1}}],[\"z=\",{\"1\":{\"43\":1}}],[\"zolotarev\",{\"1\":{\"19\":1,\"21\":1,\"28\":1}}],[\"输出output的二进制表示位\",{\"1\":{\"43\":1}}],[\"假设我们只能获取每个随机数的第k位比特信息\",{\"1\":{\"43\":1}}],[\"假设此时i为偶数\",{\"1\":{\"41\":1}}],[\"情况三\",{\"0\":{\"43\":1}}],[\"情况二\",{\"0\":{\"42\":1}}],[\"情况一\",{\"0\":{\"41\":1}}],[\"只能隔1个取1个\",{\"1\":{\"41\":1}}],[\"只能说可能是lll的界太松了\",{\"1\":{\"6\":1}}],[\"生成多个随机数进行拼接\",{\"1\":{\"40\":1}}],[\"生成一个32位的随机数取其高位\",{\"1\":{\"40\":1}}],[\"生成了一个一维ntru公私钥\",{\"1\":{\"24\":1}}],[\">=\",{\"1\":{\"40\":1}}],[\">\",{\"1\":{\"40\":1}}],[\">>=\",{\"1\":{\"40\":1}}],[\">>\",{\"1\":{\"34\":4,\"36\":3,\"39\":2,\"40\":1}}],[\"那么如果我们得到的并不是连续的随机数此时我们该做何分析\",{\"1\":{\"40\":1}}],[\"那么如果我们需要向前恢复随机数\",{\"1\":{\"38\":1}}],[\"扩展\",{\"0\":{\"40\":1}}],[\"关键操作为\",{\"1\":{\"39\":1}}],[\"关于ctf中的密码题目我可能会新开一个栏目专门只写题目wp\",{\"1\":{\"27\":1}}],[\"关于ntru的详细介绍可见\",{\"1\":{\"24\":1}}],[\"关于这里具体取何值能够攻击成功可以参考\",{\"1\":{\"23\":1}}],[\"关于每种密码的详细介绍可能会开新的博文单独撰写\",{\"1\":{\"22\":1}}],[\"关于格结构的抽象定义我们只了解到此\",{\"1\":{\"11\":1}}],[\"关于格密码的学习从很久以前已经开始\",{\"1\":{\"3\":1}}],[\"关于lwe不会在本篇做过多介绍\",{\"1\":{\"9\":1}}],[\"关于特殊因子导致的rsa分解例子太多了\",{\"1\":{\"5\":1}}],[\"关于我\",{\"0\":{\"0\":1}}],[\"做同样操作得到2\",{\"1\":{\"38\":1}}],[\"没有异或常数\",{\"1\":{\"38\":1}}],[\"异或了常数\",{\"1\":{\"38\":1}}],[\"至此原state恢复完成\",{\"1\":{\"38\":1}}],[\"位\",{\"1\":{\"38\":2,\"41\":2}}],[\"单元值代表是否发生第一次异或\",{\"1\":{\"38\":1}}],[\"列为si+397​的最高位值\",{\"1\":{\"38\":1}}],[\"第一次异或和y的奇偶性来确定\",{\"1\":{\"38\":1}}],[\"第i小向量模长\",{\"1\":{\"18\":1}}],[\"|=\",{\"1\":{\"38\":2}}],[\"|\",{\"1\":{\"38\":1}}],[\"逆向init函数\",{\"0\":{\"39\":1}}],[\"逆向twist函数\",{\"0\":{\"38\":1}}],[\"逆向extract\",{\"0\":{\"36\":1}}],[\"解题时可以考虑加以注意是否能够直接或间接的得到题目中的随机数信息\",{\"1\":{\"37\":1}}],[\"解密\",{\"1\":{\"23\":1}}],[\"解密时则将w模n\",{\"1\":{\"9\":1}}],[\"此类题型在ctf中经常出现\",{\"1\":{\"37\":1}}],[\"此时如果我们能获取每个随机数的第k位比特\",{\"1\":{\"43\":1}}],[\"此时再异或si+397+397​便可以得到si+397+624​的所有信息\",{\"1\":{\"42\":1}}],[\"此时显然我们只能够获取si+397​的第2位\",{\"1\":{\"42\":1}}],[\"此时按照extract\",{\"1\":{\"38\":1}}],[\"此时我们可以得到y的\",{\"1\":{\"41\":1}}],[\"此时我们可以列出下列关系表\",{\"1\":{\"38\":1}}],[\"此时我们可以用很巧妙的方法来找到最短向量\",{\"1\":{\"18\":1}}],[\"此时我们的目标向量变成\",{\"1\":{\"24\":1}}],[\"此时得到的序列\",{\"1\":{\"18\":1}}],[\"此时假设有个cvp预言机\",{\"1\":{\"16\":1}}],[\"此时考虑x\",{\"1\":{\"13\":1}}],[\"此时考虑商集l\",{\"1\":{\"13\":1}}],[\"此时只有格点即零向量在p\",{\"1\":{\"11\":1}}],[\"预测随机数\",{\"0\":{\"37\":1}}],[\"完整python代码实现为\",{\"1\":{\"36\":1}}],[\"⊕enfnnfn\",{\"1\":{\"36\":1}}],[\"基于此\",{\"1\":{\"36\":1}}],[\"基于二进制有限域f2​上的矩阵线性递归\",{\"1\":{\"33\":1}}],[\"→10011101001011000101011010000000=→naannnbnccncnnddenenfnnfnggghhhh​\",{\"1\":{\"36\":1}}],[\"安全分析\",{\"0\":{\"35\":1}}],[\"安全性证明涉及到上述抗碰撞哈希函数的安全性证明\",{\"1\":{\"9\":1}}],[\"安全性基于nc\",{\"1\":{\"8\":1}}],[\"<=\",{\"1\":{\"40\":1}}],[\"<\",{\"1\":{\"40\":3}}],[\"<<=\",{\"1\":{\"38\":2}}],[\"<<\",{\"1\":{\"34\":2,\"36\":5}}],[\"<1\",{\"1\":{\"11\":1}}],[\"^=\",{\"1\":{\"38\":1}}],[\"^\",{\"1\":{\"34\":7,\"36\":8,\"38\":1,\"39\":2}}],[\"提取伪随机数\",{\"1\":{\"34\":2}}],[\"提高了攻击上限\",{\"1\":{\"23\":1}}],[\"旋转状态\",{\"1\":{\"34\":2}}],[\"初始化\",{\"1\":{\"34\":2}}],[\"代码实现\",{\"0\":{\"34\":1}}],[\"代表格基为b\",{\"1\":{\"16\":1}}],[\"代表一组向量生成的最小线性子空间\",{\"1\":{\"11\":1}}],[\"代表随着n的增大\",{\"1\":{\"6\":1}}],[\"全0组合出现次数较少除外\",{\"1\":{\"33\":1}}],[\"并考虑p中k个v位向量\",{\"1\":{\"33\":1}}],[\"并且能够获取到足够多连续随机数值的情况\",{\"1\":{\"40\":1}}],[\"并且y还不能是零向量\",{\"1\":{\"11\":1}}],[\"并且包含一个索引i0​∈\",{\"1\":{\"9\":1}}],[\"并且要求他们满足都接近n\",{\"1\":{\"9\":1}}],[\"表示由x的前v位形成的数\",{\"1\":{\"33\":1}}],[\"令truncv​\",{\"1\":{\"33\":1}}],[\"比特精度的k\",{\"1\":{\"33\":1}}],[\"能比硬件实现的方法更快产生随机数\",{\"1\":{\"33\":1}}],[\"能够找到一个近似最短非零向量的短向量\",{\"1\":{\"18\":1}}],[\"能够构造向量组ci​=∑j=1i​uij​bj​使得\",{\"1\":{\"11\":1}}],[\"能够表示格中的其他任意向量\",{\"1\":{\"11\":1}}],[\"分布成立\",{\"1\":{\"33\":1}}],[\"分布\",{\"1\":{\"33\":2}}],[\"分析困难度的内容\",{\"1\":{\"26\":1}}],[\"周期非常长\",{\"1\":{\"33\":1}}],[\"该算法具有以下优点\",{\"1\":{\"33\":1}}],[\"该算法的周期为219937−1\",{\"1\":{\"33\":1}}],[\"和西村拓士在1997年开发\",{\"1\":{\"33\":1}}],[\"松本真\",{\"1\":{\"33\":1}}],[\"日语\",{\"1\":{\"33\":1}}],[\"endif\",{\"1\":{\"40\":1}}],[\"endian\",{\"1\":{\"40\":2}}],[\"end\",{\"1\":{\"40\":1}}],[\"else\",{\"1\":{\"38\":1,\"40\":1}}],[\"eeffffg=\",{\"1\":{\"36\":1}}],[\"extract\",{\"1\":{\"34\":1,\"36\":2}}],[\"extraits\",{\"1\":{\"28\":1}}],[\"et\",{\"1\":{\"28\":1}}],[\"editor\",{\"1\":{\"28\":1}}],[\"eindhoven\",{\"1\":{\"28\":1}}],[\"errors\",{\"1\":{\"28\":1}}],[\"eccc\",{\"1\":{\"28\":2}}],[\"embedding\",{\"1\":{\"17\":1}}],[\"t\",{\"1\":{\"40\":3}}],[\"tmp^res>>shift\",{\"1\":{\"39\":1}}],[\"tmp\",{\"1\":{\"36\":8,\"39\":1}}],[\"twist\",{\"1\":{\"34\":2,\"38\":1}}],[\"twister\",{\"1\":{\"33\":1}}],[\"truncv​\",{\"1\":{\"33\":3}}],[\"trier\",{\"1\":{\"28\":1}}],[\"to\",{\"1\":{\"28\":1,\"40\":1}}],[\"time\",{\"1\":{\"28\":1}}],[\"th´eorie\",{\"1\":{\"28\":1}}],[\"theoretical\",{\"1\":{\"28\":1}}],[\"theorem\",{\"1\":{\"28\":1}}],[\"theory\",{\"1\":{\"28\":3}}],[\"the\",{\"1\":{\"28\":2}}],[\"technology\",{\"1\":{\"28\":1}}],[\"technique\",{\"1\":{\"17\":1}}],[\"out\",{\"1\":{\"40\":1}}],[\"output=b402f82a2158887f\",{\"1\":{\"40\":1}}],[\"oru=d⊕v⊕x⊕1\",{\"1\":{\"38\":1}}],[\"orthogonalization\",{\"1\":{\"14\":1}}],[\"orthogonal\",{\"1\":{\"13\":2}}],[\"odlyzko\",{\"1\":{\"28\":2}}],[\"objets\",{\"1\":{\"28\":1}}],[\"on\",{\"1\":{\"28\":5}}],[\"of\",{\"1\":{\"28\":10,\"40\":2}}],[\"o\",{\"1\":{\"28\":4,\"36\":3}}],[\"更多的是从历史论文中学习各类知识的历史的本质\",{\"1\":{\"27\":1}}],[\"更平\",{\"1\":{\"24\":1}}],[\"栏目的构成\",{\"1\":{\"27\":1}}],[\"顺便在这里提及一下关于\",{\"1\":{\"27\":1}}],[\"作为新博客的第一篇博文\",{\"1\":{\"27\":1}}],[\"作为格的新格基\",{\"1\":{\"19\":1}}],[\"部分题型没有明确的给出随机数信息\",{\"1\":{\"37\":1}}],[\"部分进行普及格知识以及发展历史\",{\"1\":{\"27\":1}}],[\"部分的内容\",{\"1\":{\"27\":1}}],[\"故我们可以得到si+624​以及si​的全部信息\",{\"1\":{\"41\":1}}],[\"故名为mt19937\",{\"1\":{\"33\":1}}],[\"故干脆将那些内容作为\",{\"1\":{\"27\":1}}],[\"故在此不做深究\",{\"1\":{\"8\":1}}],[\"写完再回顾发现很多内容并没有说清楚\",{\"1\":{\"27\":1}}],[\"添加足够的高斯噪音\",{\"1\":{\"26\":1}}],[\"之后如果涉及到要进行问题难度分析在来写这个吧\",{\"1\":{\"26\":1}}],[\"之前我们使用测度理论定义了格的模体积\",{\"1\":{\"18\":1}}],[\"之前我们已经介绍过格问题的定义\",{\"1\":{\"15\":1}}],[\"现在我们把这种表示扩展到更高位空间\",{\"1\":{\"43\":1}}],[\"现在我们考虑一种更加极端的情况\",{\"1\":{\"43\":1}}],[\"现在我们经常使用的lll算法难度近似为2o\",{\"1\":{\"6\":1}}],[\"现在转回到blog上\",{\"1\":{\"32\":1}}],[\"现在还停留在应用层面\",{\"1\":{\"26\":1}}],[\"鸽了\",{\"1\":{\"26\":1}}],[\"本内容是2022发在cryptography\",{\"1\":{\"32\":1}}],[\"本篇博客本只写了\",{\"1\":{\"27\":1}}],[\"本篇博文主要是从头梳理再做一次系统的记录\",{\"1\":{\"3\":1}}],[\"本想是在这里写lwe的简单介绍以及上述关于svp\",{\"1\":{\"25\":1}}],[\"某列乘上一个数对模长的影响是累加的\",{\"1\":{\"24\":1}}],[\"−k\",{\"1\":{\"24\":2}}],[\"−1\",{\"1\":{\"13\":1}}],[\"−1y\",{\"1\":{\"13\":4}}],[\"使得最短向量期望值变得更大\",{\"1\":{\"24\":1}}],[\"核心就是在不影响格点关系的情况下增大格的模体积\",{\"1\":{\"24\":1}}],[\"所谓配平\",{\"1\":{\"24\":1}}],[\"所以如果我们能够得到某一轮的全部state数据\",{\"1\":{\"37\":1}}],[\"所以准备等介绍格在多项式中应用时再来讲这些内容吧\",{\"1\":{\"25\":1}}],[\"所以很多时候在实际攻击时我们需要对构造的格进行配平\",{\"1\":{\"24\":1}}],[\"所以此时我们还需要使用不同的方法来确定格中最小向量长度\",{\"1\":{\"18\":1}}],[\"所以此时我们相当于是一个黑名单机制\",{\"1\":{\"5\":1}}],[\"所以l\",{\"1\":{\"17\":1}}],[\"所以y的低7位就是x的低7位\",{\"1\":{\"36\":1}}],[\"所以y\",{\"1\":{\"13\":1}}],[\"所以y∈p\",{\"1\":{\"11\":1}}],[\"所以群指数无限大\",{\"1\":{\"13\":1}}],[\"所以同一个格无论取哪一组格基\",{\"1\":{\"12\":1}}],[\"所以总是能从中构造出一组基\",{\"1\":{\"11\":1}}],[\"所以b不能作为z2的格基\",{\"1\":{\"11\":1}}],[\"所以定然有x\",{\"1\":{\"11\":1}}],[\"所以x能被b表示\",{\"1\":{\"11\":1}}],[\"所以我们可以认为v就是svp的解或近似解\",{\"1\":{\"24\":1}}],[\"所以我们需要继续了解其他人的工作\",{\"1\":{\"18\":1}}],[\"所以我们依然可以任务在量子情况下格问题也是困难的\",{\"1\":{\"9\":1}}],[\"所以我们更多关注它的变体\",{\"1\":{\"6\":1}}],[\"所以1的加密结果模n\",{\"1\":{\"9\":1}}],[\"所以对于0的加密结果模n\",{\"1\":{\"9\":1}}],[\"所以任意子集之和也接近n\",{\"1\":{\"9\":1}}],[\"所以只要解决了某一格密码体系\",{\"1\":{\"5\":1}}],[\"就会导致∥v∥>σ\",{\"1\":{\"24\":1}}],[\"就可以解决基于此类格问题构建的任何密码\",{\"1\":{\"5\":1}}],[\"目前也是后量子密码的热点算法\",{\"1\":{\"24\":1}}],[\"目标向量为c的cvp\",{\"1\":{\"21\":1}}],[\"目标向量为bj​求解cvp\",{\"1\":{\"16\":1}}],[\"目标项链为c的cvp解\",{\"1\":{\"17\":1}}],[\"≥1时便很大概率可以通过lll找到这组解\",{\"1\":{\"23\":1}}],[\"≥2πen​​c1\",{\"1\":{\"23\":1}}],[\"说明我们构造的v便是svp的解\",{\"1\":{\"23\":1}}],[\"接下来要做的便是证明它是最短非零向量\",{\"1\":{\"23\":1}}],[\"接下来我们来考虑格的秩\",{\"1\":{\"11\":1}}],[\"明文为\",{\"1\":{\"23\":1}}],[\"加密\",{\"1\":{\"23\":1}}],[\"加密时进行按位加密\",{\"1\":{\"9\":1}}],[\"wordarray\",{\"1\":{\"40\":6}}],[\"words\",{\"1\":{\"40\":7}}],[\"wiki上的文章了\",{\"1\":{\"32\":1}}],[\"with\",{\"1\":{\"28\":1,\"40\":1}}],[\"wetensch\",{\"1\":{\"28\":1}}],[\"www\",{\"1\":{\"28\":1}}],[\"w\",{\"1\":{\"23\":1,\"28\":1}}],[\"乘数w\",{\"1\":{\"23\":1}}],[\"模长为f2+g2​<q​\",{\"1\":{\"24\":1}}],[\"模数m\",{\"1\":{\"23\":1}}],[\"模体积\",{\"0\":{\"12\":1}}],[\"私钥为一个超递增序列\",{\"1\":{\"23\":1}}],[\"korkin\",{\"1\":{\"28\":1}}],[\"korkine\",{\"1\":{\"19\":1,\"21\":1}}],[\"k\",{\"1\":{\"28\":1,\"33\":1,\"40\":12}}],[\"kaliski\",{\"1\":{\"28\":1}}],[\"key\",{\"1\":{\"28\":2}}],[\"knapsack\",{\"0\":{\"23\":1}}],[\"背包密码\",{\"0\":{\"23\":1}}],[\"以python中的random实现的getrandbits为例\",{\"1\":{\"40\":1}}],[\"以及前面提到的\",{\"1\":{\"26\":1}}],[\"以及其中关于分析模长和配平的一些操作\",{\"1\":{\"22\":1}}],[\"以下是目录\",{\"1\":{\"1\":1}}],[\"下面内容主要展示一些利用格基归约来攻击这些密码算法的方式\",{\"1\":{\"22\":1}}],[\"下图b1​\",{\"1\":{\"11\":1}}],[\"具体算法如下\",{\"1\":{\"21\":1}}],[\"便可以向后调用twist来预测随机数\",{\"1\":{\"37\":1}}],[\"便可以以此得到一组新的格基\",{\"1\":{\"21\":1}}],[\"便是l\",{\"1\":{\"17\":1}}],[\"δ∥bi∗​∥2≤λ1​\",{\"1\":{\"21\":1}}],[\"δ∥bi∗​∥2≤∥bi+1∗​+μi+1\",{\"1\":{\"20\":1}}],[\"系数2≤β≤d\",{\"1\":{\"21\":1}}],[\"增加运行时间提高解的精度\",{\"1\":{\"21\":1}}],[\"返回0\",{\"1\":{\"40\":1}}],[\"返回结果v=∑λi\",{\"1\":{\"21\":1}}],[\"返回为vj​\",{\"1\":{\"16\":1}}],[\"λi\",{\"1\":{\"21\":1}}],[\"λi​−\",{\"1\":{\"11\":1}}],[\"λi​\",{\"1\":{\"11\":3,\"18\":3,\"19\":1}}],[\"λi​∈z\",{\"1\":{\"11\":1}}],[\"可以发现\",{\"1\":{\"40\":1}}],[\"可以发现就是将状态中的数据进行位运算后给出\",{\"1\":{\"36\":1}}],[\"可以通过上文所述方法进行逆运算\",{\"1\":{\"39\":1}}],[\"可以得到y的最低位值\",{\"1\":{\"38\":1}}],[\"可以快速产生高质量的伪随机数\",{\"1\":{\"33\":1}}],[\"可以构造格\",{\"1\":{\"23\":1}}],[\"可以将lll应用于给定的格基来减少基向量模长从而得到cvp的解\",{\"1\":{\"21\":1}}],[\"可以把问题转化为另一种形式来简化问题进行求解\",{\"1\":{\"13\":1}}],[\"然后\",{\"1\":{\"33\":1}}],[\"然后将替换符合lovász条件的向量继续gso\",{\"1\":{\"20\":1}}],[\"然后我们可以得到如下结论\",{\"1\":{\"19\":1}}],[\"归约算法\",{\"0\":{\"20\":1}}],[\"97\",{\"1\":{\"28\":1}}],[\"93\",{\"1\":{\"28\":1}}],[\"942\",{\"1\":{\"28\":1}}],[\"99\",{\"1\":{\"28\":1}}],[\"9\",{\"1\":{\"19\":1,\"28\":1}}],[\"84\",{\"1\":{\"28\":1}}],[\"899\",{\"1\":{\"28\":1}}],[\"8\",{\"1\":{\"19\":1,\"28\":1}}],[\"∥bi​∥​\",{\"1\":{\"19\":1}}],[\"∥x−y∥<r\",{\"1\":{\"11\":1}}],[\"时称为bkz\",{\"1\":{\"21\":1}}],[\"时称为lll\",{\"1\":{\"20\":1}}],[\"时称为hkz\",{\"1\":{\"19\":1}}],[\"时b为l的一组基\",{\"1\":{\"11\":1}}],[\"πi​\",{\"1\":{\"19\":1,\"21\":1}}],[\"学过线代的应该对这一套流程非常熟悉\",{\"1\":{\"19\":1}}],[\"=0\",{\"1\":{\"19\":1}}],[\"若我们能够获取足够多的数据\",{\"1\":{\"43\":1}}],[\"若\",{\"1\":{\"19\":1}}],[\"投影\",{\"1\":{\"19\":1}}],[\"投影系数满足∣μij​≤1\",{\"1\":{\"19\":1}}],[\"投影格\",{\"1\":{\"13\":1}}],[\"623\",{\"1\":{\"39\":1}}],[\"625\",{\"1\":{\"38\":1}}],[\"624\",{\"1\":{\"34\":6,\"38\":1,\"39\":2,\"42\":1}}],[\"637\",{\"1\":{\"28\":1}}],[\"634\",{\"1\":{\"28\":1}}],[\"6\",{\"1\":{\"18\":1,\"28\":4}}],[\"证明详见\",{\"1\":{\"18\":1}}],[\"证明如下\",{\"1\":{\"16\":1}}],[\"γ2​=4\",{\"1\":{\"18\":1}}],[\"γd​≤γ2d−1​\",{\"1\":{\"18\":1}}],[\"γd​的值是多少\",{\"1\":{\"18\":1}}],[\"实际上其值可能不同\",{\"1\":{\"36\":1}}],[\"实际上在高维格中求γd​的值也是一个困难问题\",{\"1\":{\"18\":1}}],[\"实际上上面阐述的内容简单点理解就是不仅需要极大无关向量组\",{\"1\":{\"11\":1}}],[\"≤γd​​vol\",{\"1\":{\"18\":1}}],[\"drop\",{\"1\":{\"40\":1}}],[\"diophantine\",{\"1\":{\"28\":1}}],[\"differents\",{\"1\":{\"28\":1}}],[\"du\",{\"1\":{\"28\":1}}],[\"dual\",{\"1\":{\"13\":1}}],[\"def\",{\"1\":{\"34\":4,\"36\":4,\"38\":2,\"39\":4}}],[\"density\",{\"1\":{\"28\":2}}],[\"deuxi`eme\",{\"1\":{\"28\":1}}],[\"des\",{\"1\":{\"28\":1}}],[\"department\",{\"1\":{\"28\":1}}],[\"de\",{\"1\":{\"28\":5}}],[\"dg\",{\"1\":{\"24\":2}}],[\"d\",{\"1\":{\"18\":2,\"21\":1}}],[\"期望\",{\"1\":{\"18\":1}}],[\"意味着我们终于能够知道要找的最短模长是多长了\",{\"1\":{\"18\":1}}],[\"σ\",{\"1\":{\"18\":1,\"23\":1,\"24\":1}}],[\"来得到半径的近似解\",{\"1\":{\"18\":1}}],[\"秩是n+1\",{\"1\":{\"17\":1}}],[\"行列式与b相同\",{\"1\":{\"17\":1}}],[\"7\",{\"1\":{\"17\":1,\"28\":1,\"34\":1,\"36\":4}}],[\"详情可见\",{\"1\":{\"23\":1}}],[\"详见\",{\"1\":{\"17\":1}}],[\"详细可见babai原始论文\",{\"1\":{\"21\":1}}],[\"详细可参照\",{\"1\":{\"9\":1}}],[\"详细证明可见\",{\"1\":{\"16\":1}}],[\"genrand\",{\"1\":{\"40\":2}}],[\"generated\",{\"1\":{\"40\":1}}],[\"generates\",{\"1\":{\"40\":1}}],[\"generating\",{\"1\":{\"28\":1}}],[\"getrandbits\",{\"1\":{\"40\":2}}],[\"gmpy2\",{\"1\":{\"39\":1}}],[\"ggghhhh\",{\"1\":{\"36\":1}}],[\"goldwasser\",{\"1\":{\"28\":1}}],[\"goldwasser和halevi在1997年提出\",{\"1\":{\"17\":1}}],[\"goldreich\",{\"1\":{\"28\":1}}],[\"g\",{\"0\":{\"49\":1},\"1\":{\"24\":2}}],[\"gauss\",{\"1\":{\"19\":1}}],[\"gaussian\",{\"1\":{\"18\":1}}],[\"gram\",{\"0\":{\"14\":1},\"1\":{\"14\":1}}],[\"group\",{\"1\":{\"13\":1}}],[\"存在一种启发式方法利用嵌入技术\",{\"1\":{\"17\":1}}],[\"存在d×d的下三角矩阵\",{\"1\":{\"11\":1}}],[\"量化嵌入\",{\"0\":{\"17\":1}}],[\"而此时我们能够所有第奇数个数的值和第偶数个数的1\",{\"1\":{\"41\":1}}],[\"而中间的mti−1​⊕\",{\"1\":{\"39\":1}}],[\"而对格模体积的影响是累乘的\",{\"1\":{\"24\":1}}],[\"而d的取值和f与g的插值有关\",{\"1\":{\"24\":1}}],[\"而在01背包中∥v∥≈n\",{\"1\":{\"23\":1}}],[\"而在格密码中\",{\"1\":{\"5\":1}}],[\"而我们要做的就是找到这样的格基使得整个序列全局最小\",{\"1\":{\"18\":1}}],[\"而最短向量长度等于这个距离差值\",{\"1\":{\"16\":1}}],[\"根据\",{\"1\":{\"16\":1}}],[\"根据测度理论\",{\"1\":{\"12\":1}}],[\"得到s\",{\"1\":{\"38\":1}}],[\"得到一个接近均匀分布的分布\",{\"1\":{\"9\":1}}],[\"得至少存在一个奇系数\",{\"1\":{\"16\":1}}],[\"考虑我们现在只能获取所有第偶数个数的情况\",{\"1\":{\"42\":1}}],[\"考虑我们不能获取连续的32bit随机数\",{\"1\":{\"41\":1}}],[\"考虑此时恢复随机数\",{\"1\":{\"41\":1}}],[\"考虑u=v−bj​=\",{\"1\":{\"16\":1}}],[\"考虑v=u+bj​是格l\",{\"1\":{\"16\":1}}],[\"构造v=λj​\",{\"1\":{\"16\":1}}],[\"很大概率它们就是svp的解\",{\"1\":{\"16\":1}}],[\"很明显上述密码体系相对于如今的格密码体系效率非常之低\",{\"1\":{\"9\":1}}],[\"又由于它们两两非常接近\",{\"1\":{\"16\":1}}],[\"又因为0≤λ−\",{\"1\":{\"11\":1}}],[\"又因为l是一个加法子群\",{\"1\":{\"11\":1}}],[\"又因为b也是l中d个无关向量\",{\"1\":{\"11\":1}}],[\"由松本眞\",{\"1\":{\"33\":1}}],[\"由于y≫1的最高位必定为0\",{\"1\":{\"38\":1}}],[\"由于它的出现\",{\"1\":{\"20\":1}}],[\"由于封闭性vi​−bi​也是格中向量\",{\"1\":{\"16\":1}}],[\"由此通过判断是否发生异或\",{\"1\":{\"38\":1}}],[\"由此可以得到最短向量模长上界为\",{\"1\":{\"18\":1}}],[\"由此可以得出结论\",{\"1\":{\"11\":1}}],[\"由此我们可以得到一种新的方式定义格l中最短向量长度的定义\",{\"1\":{\"18\":1}}],[\"由goldreich\",{\"1\":{\"17\":1}}],[\"jacobi\",{\"1\":{\"28\":1}}],[\"joux\",{\"1\":{\"28\":1}}],[\"joux等人还在这个格的基础上再次优化\",{\"1\":{\"23\":1}}],[\"journal\",{\"1\":{\"28\":1}}],[\"j\",{\"1\":{\"16\":6,\"28\":14}}],[\"定义第i小向量模长λi​\",{\"1\":{\"18\":1}}],[\"定义格基b\",{\"1\":{\"16\":1}}],[\"定义投影πm​\",{\"1\":{\"13\":1}}],[\"向量这里写一下\",{\"1\":{\"14\":1}}],[\"简单来说就是将向量组变成正交向量组的一种方法\",{\"1\":{\"14\":1}}],[\"简单点说\",{\"1\":{\"12\":1}}],[\"简单点说就是以该点为圆心半径为r的球内没有其他点\",{\"1\":{\"11\":1}}],[\"正文\",{\"0\":{\"33\":1}}],[\"正交格定义为\",{\"1\":{\"13\":1}}],[\"正确性证明\",{\"1\":{\"9\":1}}],[\"称为正交格\",{\"1\":{\"13\":1}}],[\"也就意味着以最短向量模长为半径的n维球体内只包含一个向量\",{\"1\":{\"18\":1}}],[\"也就代表在所有的参数\",{\"1\":{\"16\":1}}],[\"也就是当πe1​c1\",{\"1\":{\"23\":1}}],[\"也就是只要∥v∥≤σ\",{\"1\":{\"23\":1}}],[\"也就是取最长向量的第i个最小值\",{\"1\":{\"18\":1}}],[\"也就是x=∑i=1d​λi​bi​\",{\"1\":{\"11\":1}}],[\"也就是说破解该密码就能有高效的量子算法攻击apprsvp\",{\"1\":{\"9\":1}}],[\"也能得到一组对偶向量\",{\"1\":{\"13\":1}}],[\"∣y\",{\"1\":{\"13\":1}}],[\"∣λi​∣<1\",{\"1\":{\"11\":1}}],[\"等价于对于y=\",{\"1\":{\"13\":1}}],[\"显然我们可以构造一个f232​方阵t满足\",{\"1\":{\"43\":1}}],[\"显然我们可以发现y的低7位就是x的低7位和2636928640的低7位异或的结果\",{\"1\":{\"36\":1}}],[\"显然我们可以发现这里的四次位运算类似\",{\"1\":{\"36\":1}}],[\"显然这是一个较强的约束\",{\"1\":{\"41\":1}}],[\"显然这对我们来说没有太多影响\",{\"1\":{\"41\":1}}],[\"显然这里的加法和乘法都存在逆运算\",{\"1\":{\"39\":1}}],[\"显然这里的最短向量期望为\",{\"1\":{\"24\":1}}],[\"显然这个格的模体积vol\",{\"1\":{\"23\":1}}],[\"显然可以构造格\",{\"1\":{\"24\":1}}],[\"显然可以得到分量bty也是整数\",{\"1\":{\"13\":1}}],[\"显然b\",{\"1\":{\"17\":1}}],[\"显然\",{\"1\":{\"16\":1}}],[\"显然vi​是格中的向量\",{\"1\":{\"16\":1}}],[\"显然不符合如今的加密系统需求\",{\"1\":{\"9\":1}}],[\"为了方便描述\",{\"1\":{\"36\":1}}],[\"为219937−1\",{\"1\":{\"33\":1}}],[\"为\",{\"1\":{\"18\":1}}],[\"为单位向量\",{\"1\":{\"13\":1}}],[\"为整数\",{\"1\":{\"13\":1}}],[\"相反zn中的每个x\",{\"1\":{\"13\":1}}],[\"任何格向量都可以写成x=bx\",{\"1\":{\"13\":1}}],[\"设state\",{\"1\":{\"43\":1}}],[\"设明文为\",{\"1\":{\"23\":1}}],[\"设格基为b=\",{\"1\":{\"16\":1}}],[\"设b是格l的基\",{\"1\":{\"13\":1}}],[\"设d是rn的一个子集\",{\"1\":{\"11\":1}}],[\"对s\",{\"1\":{\"38\":1}}],[\"对si−1​和si​生成的y值做同样操作得到si​的第\",{\"1\":{\"38\":1}}],[\"对格基进行lll得到新的格基b\",{\"1\":{\"21\":1}}],[\"对上述得到的正交向量进行单位化\",{\"1\":{\"19\":1}}],[\"对所有的1≤j≤d\",{\"1\":{\"16\":1}}],[\"对偶格的模体积为vol\",{\"1\":{\"13\":1}}],[\"对偶格l×为\",{\"1\":{\"13\":1}}],[\"对偶格\",{\"1\":{\"13\":1}}],[\"对于mt19937中的某一轮\",{\"1\":{\"43\":1}}],[\"对于如何构造这个方阵有很多方式\",{\"1\":{\"43\":1}}],[\"对于这种情况\",{\"1\":{\"43\":1}}],[\"对于extract\",{\"1\":{\"36\":1}}],[\"对于背包密码的工作不止于此\",{\"1\":{\"23\":1}}],[\"对于一组格基\",{\"1\":{\"21\":1}}],[\"对于一组基当满足size\",{\"1\":{\"19\":1}}],[\"对于d≥2时\",{\"1\":{\"18\":1}}],[\"对于最短向量\",{\"1\":{\"18\":1}}],[\"对于cvp的目标向量为c\",{\"1\":{\"17\":1}}],[\"对于u=∑λi​bi​是格的最短非零向量\",{\"1\":{\"16\":1}}],[\"对于不满秩的整格l\",{\"1\":{\"13\":1}}],[\"对于对偶向量y\",{\"1\":{\"13\":1}}],[\"对于格基b\",{\"1\":{\"21\":1}}],[\"对于格基\",{\"1\":{\"20\":1}}],[\"对于格l\",{\"1\":{\"13\":1,\"17\":1}}],[\"对于格中的不同格基\",{\"1\":{\"12\":1}}],[\"对于全秩子格m来说\",{\"1\":{\"13\":1}}],[\"对于rn中的满秩格l\",{\"1\":{\"12\":1}}],[\"对于rn中的秩为d的格\",{\"1\":{\"11\":1}}],[\"对于秩为d的格l\",{\"1\":{\"12\":1,\"13\":2,\"18\":1}}],[\"对于基向量构成的矩阵b成为格的格基\",{\"1\":{\"11\":1}}],[\"对于比特1\",{\"1\":{\"9\":1}}],[\"对于比特0\",{\"1\":{\"9\":1}}],[\"对于apprsvp\",{\"1\":{\"6\":1}}],[\"且我们只取第奇数位数\",{\"1\":{\"41\":1}}],[\"且2636928640低7位为0\",{\"1\":{\"36\":1}}],[\"且能size\",{\"1\":{\"20\":1}}],[\"且对于高维格\",{\"1\":{\"18\":1}}],[\"且二者距离dist\",{\"1\":{\"16\":1}}],[\"且模体积为vol\",{\"1\":{\"13\":1}}],[\"且每个加密比特都会变成o\",{\"1\":{\"9\":1}}],[\"∈z\",{\"1\":{\"13\":1}}],[\"∈zn\",{\"1\":{\"13\":2}}],[\"∈z∣x∈l\",{\"1\":{\"13\":1}}],[\"∈rn是一个秩为d−r的投影格\",{\"1\":{\"13\":1}}],[\"∈l\",{\"1\":{\"11\":1}}],[\"选取两个基向量b1​\",{\"1\":{\"19\":1}}],[\"选取一个秩为r的原始子格m⊂l\",{\"1\":{\"13\":1}}],[\"选取私钥h∈\",{\"1\":{\"9\":1}}],[\"有对于参数\",{\"1\":{\"16\":1}}],[\"有l×⊆\",{\"1\":{\"13\":1}}],[\"有\",{\"1\":{\"13\":1}}],[\"有r>0\",{\"1\":{\"12\":1}}],[\"impl\",{\"1\":{\"40\":1}}],[\"import\",{\"1\":{\"39\":1}}],[\"improved\",{\"1\":{\"28\":1}}],[\"i的最高位\",{\"1\":{\"38\":1}}],[\"if\",{\"1\":{\"34\":2,\"38\":1,\"40\":6}}],[\"i\",{\"1\":{\"34\":12,\"36\":2,\"38\":11,\"39\":12,\"40\":7,\"43\":1}}],[\"its\",{\"1\":{\"28\":1}}],[\"input=8c0e6396dd176fc0\",{\"1\":{\"40\":1}}],[\"invert\",{\"1\":{\"39\":4}}],[\"inverse\",{\"1\":{\"36\":6}}],[\"inv\",{\"1\":{\"38\":1,\"39\":2}}],[\"init\",{\"1\":{\"34\":1,\"39\":2}}],[\"integer\",{\"1\":{\"40\":1}}],[\"international\",{\"1\":{\"28\":1}}],[\"int\",{\"1\":{\"34\":1,\"39\":1,\"40\":3}}],[\"int32\",{\"1\":{\"34\":4,\"39\":4,\"42\":1}}],[\"introduction\",{\"1\":{\"28\":1}}],[\"inequalities\",{\"1\":{\"28\":1}}],[\"inhomogeneous\",{\"1\":{\"28\":1}}],[\"in\",{\"1\":{\"28\":9,\"34\":2,\"36\":2,\"38\":1,\"39\":3}}],[\"instances\",{\"1\":{\"28\":1}}],[\"index\",{\"1\":{\"13\":1}}],[\"i+397+1\",{\"1\":{\"42\":1}}],[\"i+397\",{\"1\":{\"42\":1}}],[\"i+34​≤\",{\"1\":{\"19\":1}}],[\"i++\",{\"1\":{\"40\":1}}],[\"i+β−1\",{\"1\":{\"21\":1}}],[\"i​bi∗​∥2\",{\"1\":{\"20\":1}}],[\"i=1∑m​λi​bi​\",{\"1\":{\"11\":1}}],[\"i=1∑n​αi​vi​​αi​∈z\",{\"1\":{\"5\":1}}],[\"free\",{\"1\":{\"40\":1}}],[\"frombytearray\",{\"1\":{\"40\":1}}],[\"fromunsignedlong\",{\"1\":{\"40\":1}}],[\"fromlong\",{\"1\":{\"40\":1}}],[\"from\",{\"1\":{\"28\":2,\"39\":1,\"40\":1}}],[\"fill\",{\"1\":{\"40\":1}}],[\"fig\",{\"1\":{\"5\":1}}],[\"fast\",{\"1\":{\"40\":1}}],[\"for\",{\"1\":{\"34\":2,\"36\":2,\"38\":1,\"39\":3,\"40\":2}}],[\"f\",{\"1\":{\"24\":6}}],[\"full\",{\"1\":{\"13\":1}}],[\"每个子格都是子群\",{\"1\":{\"13\":1}}],[\"子格和l能有相同的秩但不等于l\",{\"1\":{\"13\":1}}],[\"子格\",{\"1\":{\"13\":1}}],[\"派生格\",{\"0\":{\"13\":1}}],[\"因此有上述模体积的定义\",{\"1\":{\"12\":1}}],[\"因为我们有足够多的信息\",{\"1\":{\"43\":1}}],[\"因为我们是\",{\"1\":{\"18\":1}}],[\"因为si+624​中的错误会扩散至si​\",{\"1\":{\"41\":1}}],[\"因为si+624​只和si​\",{\"1\":{\"41\":1}}],[\"因为svp可以按照下列方法转为cvp求解\",{\"1\":{\"16\":1}}],[\"因为对于最短向量来说\",{\"1\":{\"24\":1}}],[\"因为其相比其他后量子公钥密码速度很快\",{\"1\":{\"24\":1}}],[\"因为可能有多个无关向量同时取最小值\",{\"1\":{\"18\":1}}],[\"因为可能会让分解很容易\",{\"1\":{\"5\":1}}],[\"因为l\",{\"1\":{\"17\":1}}],[\"因为根据\",{\"1\":{\"16\":1}}],[\"因为后续会提到gso\",{\"1\":{\"14\":1}}],[\"因为下三角阵乘上b不改变线性无关性\",{\"1\":{\"11\":1}}],[\"因为之前说了λi​不全是整数\",{\"1\":{\"11\":1}}],[\"因为x\",{\"1\":{\"11\":1}}],[\"因为此时x不是b的整系数线性组合\",{\"1\":{\"11\":1}}],[\"因为b是格基\",{\"1\":{\"11\":1}}],[\"因为并不要求这组线性无关向量的个数是n\",{\"1\":{\"11\":1}}],[\"因为这不是我的研究方向\",{\"1\":{\"8\":1}}],[\"因为都是有限域运算\",{\"1\":{\"5\":1}}],[\"因为攻击同规格的格问题难度几乎一致\",{\"1\":{\"5\":1}}],[\"∩l∣\",{\"1\":{\"18\":1}}],[\"∩l∣vr​​\",{\"1\":{\"12\":1}}],[\"∩d=\",{\"1\":{\"11\":1}}],[\"0101101\",{\"1\":{\"36\":1}}],[\"0x9908b0df\",{\"1\":{\"34\":1,\"38\":1}}],[\"0x7fffffff\",{\"1\":{\"34\":1,\"38\":2,\"42\":1}}],[\"0x80000000\",{\"1\":{\"34\":1,\"38\":2,\"42\":1}}],[\"0xffffffff\",{\"1\":{\"34\":1,\"36\":2,\"39\":1}}],[\"0≤i<p\",{\"1\":{\"33\":1}}],[\"03\",{\"1\":{\"28\":1}}],[\"0\",{\"1\":{\"12\":3,\"18\":1,\"23\":2,\"34\":6,\"38\":2,\"39\":3,\"40\":6}}],[\"反过来找到了这个格的svp解便可以得到对于格l\",{\"1\":{\"17\":1}}],[\"反过来说属于不同格的格基其vol\",{\"1\":{\"12\":1}}],[\"反之如果b不是格基\",{\"1\":{\"11\":1}}],[\"都做这个操作\",{\"1\":{\"16\":1}}],[\"都能变成一个格向量\",{\"1\":{\"13\":1}}],[\"都不变\",{\"1\":{\"12\":1}}],[\"都可以通过乘上一个行列式为±1的单位矩阵来进行变换\",{\"1\":{\"12\":1}}],[\"都存在r>0使得b\",{\"1\":{\"11\":1}}],[\"​即为cvp的一个近似解\",{\"1\":{\"21\":1}}],[\"​bi\",{\"1\":{\"21\":1}}],[\"​最接近c\",{\"1\":{\"21\":1}}],[\"​∣bn​∣0​​\",{\"1\":{\"17\":1}}],[\"​为投影在包含m的最小子空间的正交补\",{\"1\":{\"13\":1}}],[\"​\",{\"1\":{\"12\":1,\"21\":2}}],[\"clinic\",{\"1\":{\"40\":1}}],[\"class\",{\"1\":{\"34\":1}}],[\"char\",{\"1\":{\"40\":1}}],[\"ch\",{\"1\":{\"28\":1}}],[\"code\",{\"1\":{\"40\":1}}],[\"codes\",{\"1\":{\"28\":1}}],[\"coster\",{\"1\":{\"28\":1}}],[\"combinatorica\",{\"1\":{\"28\":2}}],[\"complexity\",{\"1\":{\"28\":1}}],[\"complement\",{\"1\":{\"13\":1}}],[\"comput\",{\"1\":{\"28\":1}}],[\"computational\",{\"1\":{\"28\":1}}],[\"computer\",{\"1\":{\"28\":3}}],[\"computing\",{\"1\":{\"28\":2}}],[\"constructions\",{\"1\":{\"28\":1}}],[\"conference\",{\"1\":{\"28\":1}}],[\"cryptosystem\",{\"1\":{\"28\":1}}],[\"cryptosystems\",{\"1\":{\"28\":1}}],[\"crypto\",{\"1\":{\"28\":1}}],[\"cryptographic\",{\"1\":{\"28\":1}}],[\"cryptography\",{\"1\":{\"28\":4}}],[\"cryptology\",{\"1\":{\"28\":2}}],[\"c≡i=1∑n​bi​vi​\",{\"1\":{\"23\":1}}],[\"c\",{\"1\":{\"18\":1,\"28\":7}}],[\"c−x\",{\"1\":{\"17\":1}}],[\"cd​\",{\"1\":{\"11\":1}}],[\"c1​\",{\"1\":{\"11\":1}}],[\"cvp问题相互转换的实际应用在格攻击lwe密码算法中的体现\",{\"1\":{\"25\":1}}],[\"cvp的解中至少有一个解是svp的解\",{\"1\":{\"16\":1}}],[\"cvp的解v要满足到bj​的距离不能超过dist\",{\"1\":{\"16\":1}}],[\"cvp\",{\"1\":{\"6\":1}}],[\"unsigned\",{\"1\":{\"40\":2}}],[\"university\",{\"1\":{\"28\":1}}],[\"uni\",{\"1\":{\"28\":1}}],[\"u=d⊕v⊕x\",{\"1\":{\"38\":1}}],[\"uint32\",{\"1\":{\"40\":5}}],[\"ui​线性无关\",{\"1\":{\"18\":1}}],[\"ui​∈lmin​1≤j≤imax​∥uj​∥\",{\"1\":{\"18\":1}}],[\"uij​∈rd×d\",{\"1\":{\"11\":1}}],[\"usvp\",{\"1\":{\"6\":1}}],[\"还是在这里写一下\",{\"1\":{\"19\":1}}],[\"还有一个重要的子格关系为原始子格\",{\"1\":{\"13\":1}}],[\"还有另一种定义模体积的方式\",{\"1\":{\"12\":1}}],[\"还需要这组向量是完备的\",{\"1\":{\"11\":1}}],[\"还要注意的是\",{\"1\":{\"11\":1}}],[\"到\",{\"1\":{\"11\":1}}],[\"整系数线性表示\",{\"1\":{\"11\":1}}],[\"53\",{\"1\":{\"28\":1}}],[\"51\",{\"1\":{\"28\":1}}],[\"5\",{\"1\":{\"11\":1,\"16\":1,\"28\":1}}],[\"引用一下\",{\"1\":{\"11\":1}}],[\"y→y≫1→⊕0x9908b0df→=⊕si+397​==out=​aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaux0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaau10011001000010001011000011011111bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbvccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddd​\",{\"1\":{\"41\":1}}],[\"y→y≫1→⊕0x9908b0df→=⊕si+397​==out=​aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaux0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaau10011001000010001011000011011111bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccccccccccccvdddddddddddddddddddddddddddddddd​\",{\"1\":{\"38\":1}}],[\"york\",{\"1\":{\"28\":1}}],[\"y\",{\"1\":{\"13\":7,\"34\":17,\"36\":26,\"38\":9,\"42\":1}}],[\"y∈span\",{\"1\":{\"13\":1}}],[\"y∈rn\",{\"1\":{\"11\":1,\"13\":1}}],[\"y=x−x\",{\"1\":{\"11\":1}}],[\"封闭性\",{\"1\":{\"11\":1}}],[\"记为\",{\"1\":{\"13\":1}}],[\"记\",{\"1\":{\"11\":2}}],[\"中使用了一种选择乘数的方式得到t的每一行\",{\"1\":{\"43\":1}}],[\"中对ntru介绍的例子\",{\"1\":{\"24\":1}}],[\"中定义了hermite常数γd​是所有秩为d的格中λ1​\",{\"1\":{\"18\":1}}],[\"中向量\",{\"1\":{\"16\":1}}],[\"中的格点数近似等于其中的向量数\",{\"1\":{\"12\":1}}],[\"中的格点数为n\",{\"1\":{\"12\":1}}],[\"中的例图\",{\"1\":{\"11\":1}}],[\"中\",{\"1\":{\"11\":1}}],[\"中第六节内容\",{\"1\":{\"9\":1}}],[\"充分必要证明\",{\"1\":{\"11\":1}}],[\"py\",{\"1\":{\"40\":2}}],[\"pymem\",{\"1\":{\"40\":2}}],[\"pylong\",{\"1\":{\"40\":3}}],[\"pyexc\",{\"1\":{\"40\":1}}],[\"pyerr\",{\"1\":{\"40\":2}}],[\"pyobject\",{\"1\":{\"40\":2}}],[\"python代码实现为\",{\"1\":{\"34\":1,\"38\":1}}],[\"pipher\",{\"1\":{\"28\":2}}],[\"posts\",{\"0\":{\"47\":1}}],[\"point\",{\"1\":{\"28\":1}}],[\"polynomial\",{\"1\":{\"28\":1}}],[\"pol\",{\"1\":{\"28\":1}}],[\"path\",{\"1\":{\"40\":1}}],[\"pages\",{\"1\":{\"28\":2}}],[\"parallelepiped\",{\"1\":{\"11\":1}}],[\"public\",{\"1\":{\"28\":2}}],[\"prng\",{\"2\":{\"46\":1}}],[\"print\",{\"1\":{\"36\":1,\"39\":1}}],[\"primitive\",{\"1\":{\"13\":1}}],[\"preliminary\",{\"1\":{\"28\":1}}],[\"problem\",{\"1\":{\"28\":1}}],[\"problems\",{\"1\":{\"28\":3}}],[\"proc\",{\"1\":{\"28\":3}}],[\"projected\",{\"1\":{\"13\":1}}],[\"p\",{\"0\":{\"49\":1},\"1\":{\"11\":1,\"28\":3}}],[\"或者说近似解\",{\"1\":{\"23\":1}}],[\"或者说n维平行空间\",{\"1\":{\"11\":1}}],[\"或者说对于n个线性无关的向量v1​\",{\"1\":{\"5\":1}}],[\"是一个格点\",{\"1\":{\"23\":1}}],[\"是非递减的\",{\"1\":{\"18\":1}}],[\"是称为全秩子格\",{\"1\":{\"13\":1}}],[\"是l的一组基\",{\"1\":{\"11\":1}}],[\"是格向量组的整系数组合\",{\"1\":{\"11\":1}}],[\"是格中最主要的问题\",{\"1\":{\"6\":1}}],[\"是d个无关向量\",{\"1\":{\"11\":1}}],[\"但其中我们针对的都是以32bit为一组\",{\"1\":{\"40\":1}}],[\"但可以泄漏的其他信息得到随机数\",{\"1\":{\"37\":1}}],[\"但是si+397​的第二位配合si+397+1​\",{\"1\":{\"42\":1}}],[\"但是到此我们的分析并没有那么精确\",{\"1\":{\"23\":1}}],[\"但是有些时候这些无关向量并不一定是格基\",{\"1\":{\"18\":1}}],[\"但hermite给出了hermite不等式证明了γd​的上界\",{\"1\":{\"18\":1}}],[\"但很多时候所构造的格并不满足这一特征\",{\"1\":{\"18\":1}}],[\"但因为存在非零向量属于p\",{\"1\":{\"11\":1}}],[\"但系数不全是整数\",{\"1\":{\"11\":1}}],[\"但子空间的每个极大无关向量组不一定能构成格基\",{\"1\":{\"11\":1}}],[\"但对于要求svp的解还是需要2o\",{\"1\":{\"6\":1}}],[\"当参数大于32时\",{\"1\":{\"40\":1}}],[\"当参数小于32时\",{\"1\":{\"40\":1}}],[\"当参数为0时\",{\"1\":{\"40\":1}}],[\"当我们能够逆向extract\",{\"1\":{\"37\":1}}],[\"当可size\",{\"1\":{\"21\":1}}],[\"当因子δ∈\",{\"1\":{\"20\":1}}],[\"当然投影时仍需保证结果是离散的\",{\"1\":{\"13\":1}}],[\"当dim\",{\"1\":{\"13\":1}}],[\"当且仅当秩为k的子格m的基b可以通过添加d−k个向量扩充为原格的一个基\",{\"1\":{\"13\":1}}],[\"当且仅当不存在非零格向量x∈l使得x∈p\",{\"1\":{\"11\":1}}],[\"当且仅当d=n时格才是满秩的\",{\"1\":{\"11\":1}}],[\"当它没有聚点时\",{\"1\":{\"11\":1}}],[\"注意格并不一定是满秩的\",{\"1\":{\"11\":1}}],[\"by\",{\"1\":{\"40\":1}}],[\"be\",{\"1\":{\"40\":1}}],[\"berlin\",{\"1\":{\"28\":3}}],[\"bit\",{\"1\":{\"40\":1}}],[\"bits\",{\"1\":{\"36\":2,\"40\":4}}],[\"bits=32\",{\"1\":{\"36\":2}}],[\"bi​\",{\"1\":{\"11\":2,\"23\":1}}],[\"basis\",{\"1\":{\"28\":1}}],[\"bases\",{\"1\":{\"28\":1}}],[\"based\",{\"1\":{\"28\":4}}],[\"babai\",{\"1\":{\"28\":1}}],[\"babai具体操作为\",{\"1\":{\"21\":1}}],[\"babai在1986年发表了两种求解cvp近似解的方法\",{\"1\":{\"21\":1}}],[\"babai方法和bkz算法\",{\"0\":{\"21\":1}}],[\"bkz格归约算法\",{\"1\":{\"21\":1}}],[\"bmin\",{\"1\":{\"21\":1}}],[\"block\",{\"1\":{\"21\":1}}],[\"b2​\",{\"1\":{\"19\":2}}],[\"b2​虽然是z2的极大线性无关组\",{\"1\":{\"11\":1}}],[\"bn​\",{\"1\":{\"17\":1}}],[\"bj​+∑i=j​λi​bi​−bj​是l\",{\"1\":{\"16\":1}}],[\"bj​\",{\"1\":{\"16\":5}}],[\"bj​−1\",{\"1\":{\"16\":1}}],[\"bj+1​\",{\"1\":{\"16\":1}}],[\"bt\",{\"1\":{\"13\":5}}],[\"bty\",{\"1\":{\"13\":1}}],[\"btb\",{\"1\":{\"12\":1}}],[\"bd​中找出一组格基\",{\"1\":{\"11\":1}}],[\"bd​\",{\"1\":{\"11\":1,\"12\":2,\"16\":2,\"20\":1,\"21\":1}}],[\"b1​和b2​张成的格和z2的区别\",{\"1\":{\"11\":1}}],[\"b1​\",{\"1\":{\"11\":1,\"12\":2,\"16\":2,\"17\":1,\"19\":1,\"20\":1,\"21\":2}}],[\"bx\",{\"1\":{\"11\":1,\"13\":2}}],[\"b\",{\"1\":{\"11\":10,\"12\":1,\"16\":6,\"17\":5,\"23\":2,\"28\":2}}],[\"则可以构造\",{\"1\":{\"43\":1}}],[\"则可以由此得到si+624​的第1和第\",{\"1\":{\"41\":1}}],[\"则需要对twist函数进行逆向\",{\"1\":{\"38\":1}}],[\"则我们可以得到\",{\"1\":{\"43\":1}}],[\"则我们可以得到si+1​\",{\"1\":{\"41\":1}}],[\"则我们可以构造\",{\"1\":{\"17\":1}}],[\"则我们变成\",{\"1\":{\"24\":1}}],[\"则密文\",{\"1\":{\"23\":1}}],[\"则进行正交化得到正交向量\",{\"1\":{\"19\":1}}],[\"则此时我们可以使用斯特林公式去近似n维球体积中参数\",{\"1\":{\"18\":1}}],[\"则此时\",{\"1\":{\"17\":1}}],[\"则至少存在一个λi​为奇数\",{\"1\":{\"16\":1}}],[\"则πm​\",{\"1\":{\"13\":1}}],[\"则称m为原始子格\",{\"1\":{\"13\":1}}],[\"则没有上述关系\",{\"1\":{\"13\":1}}],[\"则m称为l的子格\",{\"1\":{\"13\":1}}],[\"则\",{\"1\":{\"12\":1,\"13\":1}}],[\"则有格点v=\",{\"1\":{\"24\":1}}],[\"则有\",{\"1\":{\"11\":1,\"23\":1}}],[\"则他们的差也属于格l\",{\"1\":{\"11\":1}}],[\"则格中存在非零向量x∈p\",{\"1\":{\"11\":1}}],[\"则格的表示可以写为\",{\"1\":{\"11\":1}}],[\"则∣λi​∣<1\",{\"1\":{\"11\":1}}],[\"则每个向量都可以由b的整系数组合构成\",{\"1\":{\"11\":1}}],[\"则在求和时加上\",{\"1\":{\"9\":1}}],[\"如果下列成立则称其v\",{\"1\":{\"33\":1}}],[\"如果我们让f的值变得更大\",{\"1\":{\"24\":1}}],[\"如果解决了cvp都能解决相应的svp\",{\"1\":{\"16\":1}}],[\"如果l满秩\",{\"1\":{\"13\":1}}],[\"如果格l∈rn的子集m⊂l且m也是格\",{\"1\":{\"13\":1}}],[\"如果上面的数学描述看不懂的话看图应该就很轻松了\",{\"1\":{\"11\":1}}],[\"如果x∈p\",{\"1\":{\"11\":1}}],[\"如果b=\",{\"1\":{\"11\":1}}],[\"如果它具有离散性则称为格\",{\"1\":{\"11\":1}}],[\"如果余数很小则为0\",{\"1\":{\"9\":1}}],[\"+∑i=j​λi​bi​符合上述要求且是格中向量\",{\"1\":{\"16\":1}}],[\"+\",{\"1\":{\"11\":1,\"34\":5,\"38\":3,\"39\":2,\"40\":1,\"42\":1}}],[\"right\",{\"1\":{\"36\":3,\"39\":2}}],[\"ring\",{\"1\":{\"28\":1}}],[\"range\",{\"1\":{\"34\":2,\"36\":2,\"38\":1,\"39\":3}}],[\"randomobject\",{\"1\":{\"40\":1}}],[\"random\",{\"1\":{\"28\":1,\"40\":3}}],[\"rank\",{\"1\":{\"13\":1}}],[\"recover\",{\"1\":{\"36\":2,\"38\":3,\"39\":2}}],[\"reciprocal\",{\"1\":{\"28\":1}}],[\"result\",{\"1\":{\"40\":3}}],[\"res\",{\"1\":{\"36\":6,\"39\":4}}],[\"return\",{\"1\":{\"34\":2,\"36\":4,\"38\":2,\"39\":4,\"40\":5}}],[\"reine\",{\"1\":{\"28\":1}}],[\"regev\",{\"1\":{\"28\":3}}],[\"reference\",{\"0\":{\"28\":1}}],[\"reduce\",{\"1\":{\"19\":1}}],[\"reduced且满足\",{\"1\":{\"20\":1,\"21\":1}}],[\"reduced的基础且∥bi∗​∥=λi​\",{\"1\":{\"19\":1}}],[\"reduced\",{\"1\":{\"19\":2,\"20\":1,\"21\":1}}],[\"reduction\",{\"1\":{\"19\":3,\"21\":1,\"28\":3}}],[\"r≈2πen​​\",{\"1\":{\"18\":1}}],[\"r足够大时\",{\"1\":{\"12\":1}}],[\"rn空间中的格一定至少有一组基\",{\"1\":{\"11\":1}}],[\"rn\",{\"1\":{\"11\":1}}],[\"r\",{\"0\":{\"49\":1},\"1\":{\"11\":2,\"12\":4,\"18\":1,\"40\":4}}],[\"x⋅t=s\",{\"1\":{\"43\":1}}],[\"x⋅t=z\",{\"1\":{\"43\":1}}],[\"x19967​\",{\"1\":{\"43\":1}}],[\"x19966​\",{\"1\":{\"43\":1}}],[\"x1​\",{\"1\":{\"43\":2}}],[\"x31​\",{\"1\":{\"43\":1}}],[\"x30​\",{\"1\":{\"43\":1}}],[\"x0​\",{\"1\":{\"43\":2}}],[\"x=\",{\"1\":{\"43\":2}}],[\"x=i=1∑d​λi​bi​\",{\"1\":{\"11\":1}}],[\"xx<<72636928640y​→aaaabbbbccccddddeeeeffffgggghhhh⊕→bccccddddeeeeffffgggghhhh0000000\",{\"1\":{\"36\":1}}],[\"x未知\",{\"1\":{\"36\":1}}],[\"xi+k−1​\",{\"1\":{\"33\":1}}],[\"xi+1​\",{\"1\":{\"33\":1}}],[\"xi​\",{\"1\":{\"33\":1}}],[\"x∈zn\",{\"1\":{\"11\":1}}],[\"x\",{\"1\":{\"11\":4,\"13\":9,\"33\":1,\"34\":2,\"36\":2,\"39\":2,\"40\":1}}],[\"离散性\",{\"1\":{\"11\":1}}],[\"在\",{\"1\":{\"43\":1}}],[\"在上文中我们介绍了对于mt19937各个函数的逆向分析以及算法实现\",{\"1\":{\"40\":1}}],[\"在上文中我们提到如果得到了某一轮state的全部信息便可以向后预测随机数\",{\"1\":{\"38\":1}}],[\"在上面的两次异或中\",{\"1\":{\"38\":1}}],[\"在1≤k≤623都满足k\",{\"1\":{\"33\":1}}],[\"在18世纪末\",{\"1\":{\"19\":1}}],[\"在这里我不会写太多ctf中实际题目的应用及代码\",{\"1\":{\"27\":1}}],[\"在此不在一一介绍\",{\"1\":{\"18\":1}}],[\"在此不做介绍\",{\"1\":{\"18\":1}}],[\"在他的原始工作研究基于格的二次型\",{\"1\":{\"18\":1}}],[\"在了解下面的解决问题方法前我们需要先阐述一些定义和理论\",{\"1\":{\"18\":1}}],[\"在格攻击的例子中或许我会写道对偶格的用法\",{\"1\":{\"13\":1}}],[\"在对偶格中\",{\"1\":{\"13\":1}}],[\"在前面我们已经描述了使用线性无关的向量组作为一组基来表示或者说生成格\",{\"1\":{\"11\":1}}],[\"在群论中\",{\"1\":{\"11\":1}}],[\"在高维格中这是一个困难问题\",{\"1\":{\"6\":1}}],[\"二是lwe显示出svp可能有量子算法\",{\"1\":{\"9\":1}}],[\"它是一种安全性基于多项式环上的svp构造的公钥密码体系\",{\"1\":{\"24\":1}}],[\"它是一组向量在n维空间中有着周期性的点集\",{\"1\":{\"5\":1}}],[\"它主要工作便是在hkz和lll中进行折中选择\",{\"1\":{\"21\":1}}],[\"它包含如下步骤\",{\"1\":{\"19\":1}}],[\"它们的具体定义如下\",{\"1\":{\"11\":1}}],[\"它基于svp的最坏情况量子难度\",{\"1\":{\"9\":1}}],[\"后记\",{\"0\":{\"27\":1}}],[\"后面可能我会写单独的博文\",{\"1\":{\"9\":1}}],[\"后续从格的性质开始介绍格的各种属性以及各类问题的解决方式\",{\"1\":{\"27\":1}}],[\"后续coster\",{\"1\":{\"23\":1}}],[\"后续schnorr在babai等的基础上提出了bkz归约算法\",{\"1\":{\"21\":1}}],[\"后续有了非常多基于格归约的密码攻击方法\",{\"1\":{\"20\":1}}],[\"后续基于minkowski凸体的定理还可以得到关于γd​的线性上下界\",{\"1\":{\"18\":1}}],[\"后续regev提出了基于格基的lwe问题密码体系\",{\"1\":{\"9\":1}}],[\"后续的工作都是来减少常数c来提高安全上限\",{\"1\":{\"8\":1}}],[\"后续还有很多其他优化后的其他算法\",{\"1\":{\"6\":1}}],[\"41\",{\"1\":{\"28\":1}}],[\"41​\",{\"1\":{\"20\":1}}],[\"4022730752\",{\"1\":{\"34\":1,\"36\":2}}],[\"40\",{\"1\":{\"28\":1}}],[\"4\",{\"1\":{\"9\":1,\"28\":2,\"40\":2}}],[\"大小\",{\"1\":{\"9\":1}}],[\"大小的公钥\",{\"1\":{\"9\":1}}],[\"大致就是像格中添加足够的高斯噪音\",{\"1\":{\"9\":1}}],[\"用n维的格就需要o\",{\"1\":{\"9\":1}}],[\"再利用已知信息和未知信息之间的约束条件进行扩散\",{\"1\":{\"43\":1}}],[\"再究格问题\",{\"0\":{\"15\":1}}],[\"再从这个分布的统计距离来分析格问题的困难度\",{\"1\":{\"9\":1}}],[\"再探格密码\",{\"0\":{\"3\":1}}],[\"同理可以向前恢复得到x的所有值\",{\"1\":{\"36\":1}}],[\"同理我们还可以考虑是否有方法将cvp转化为svp\",{\"1\":{\"17\":1}}],[\"同理\",{\"1\":{\"9\":1,\"38\":1}}],[\"同时构造\",{\"1\":{\"43\":1}}],[\"同时又有第2位的约束\",{\"1\":{\"41\":1}}],[\"同时我们可以对si+1​和si+2​生成的y值做同样操作得到同样si+1​的最高位\",{\"1\":{\"38\":1}}],[\"同时我们考虑对λi​取整\",{\"1\":{\"11\":1}}],[\"同时y的值即为si​的最高位和si+1​的第\",{\"1\":{\"38\":1}}],[\"同时可以发现后续的随机数完全依赖于上一轮的state\",{\"1\":{\"37\":1}}],[\"同时达到最小值得基可能不一定存在\",{\"1\":{\"18\":1}}],[\"同时每个具有离散性的子群也都是子格\",{\"1\":{\"13\":1}}],[\"同时格密码还有下列优势\",{\"1\":{\"5\":1}}],[\"同时发现用格来构建密码体系的安全性基于格问题的最坏情况\",{\"1\":{\"5\":1}}],[\"否则为1\",{\"1\":{\"9\":1}}],[\"high\",{\"1\":{\"38\":4}}],[\"hierarchy\",{\"1\":{\"28\":1}}],[\"hoffstein\",{\"1\":{\"28\":2}}],[\"halevi\",{\"1\":{\"28\":1}}],[\"hard\",{\"1\":{\"28\":1}}],[\"http\",{\"1\":{\"28\":1}}],[\"hkz\",{\"1\":{\"19\":1}}],[\"heidelberg\",{\"1\":{\"28\":3}}],[\"hermite\",{\"1\":{\"19\":1,\"28\":2}}],[\"hermite不等式\",{\"1\":{\"18\":1}}],[\"hermite首次证明了最短向量模长的上界\",{\"1\":{\"18\":1}}],[\"heuristic\",{\"1\":{\"18\":1}}],[\"h余数很大\",{\"1\":{\"9\":1}}],[\"h整数倍\",{\"1\":{\"9\":3}}],[\"h\",{\"1\":{\"9\":1,\"28\":3}}],[\"h的余数很小\",{\"1\":{\"9\":1}}],[\"h的奇数倍\",{\"1\":{\"9\":1}}],[\"h的整数倍\",{\"1\":{\"9\":1}}],[\"的二进制表示为\",{\"1\":{\"43\":1}}],[\"的所有信息\",{\"1\":{\"42\":1}}],[\"的全部信息\",{\"1\":{\"42\":1}}],[\"的svp解\",{\"1\":{\"17\":1}}],[\"的模体积也与l相同\",{\"1\":{\"17\":1}}],[\"的最短向量\",{\"1\":{\"16\":2}}],[\"的维度\",{\"1\":{\"11\":1}}],[\"的加法子群\",{\"1\":{\"11\":1}}],[\"的随机子集求和并模n\",{\"1\":{\"9\":1}}],[\"的运算时间\",{\"1\":{\"6\":1}}],[\"将线性组合系数取整得到\",{\"1\":{\"21\":1}}],[\"将等式变为\",{\"1\":{\"18\":1}}],[\"将cvp转化为svp\",{\"1\":{\"17\":1}}],[\"将格投影到某个子空间上形成投影格\",{\"1\":{\"13\":1}}],[\"将\",{\"1\":{\"9\":1}}],[\"要求ai0​​接近n\",{\"1\":{\"9\":1}}],[\"most\",{\"1\":{\"40\":1}}],[\"modm\",{\"1\":{\"23\":3}}],[\"must\",{\"1\":{\"40\":1}}],[\"mti−1​≫30\",{\"1\":{\"39\":1}}],[\"mti\",{\"1\":{\"34\":5}}],[\"mt\",{\"1\":{\"34\":12,\"39\":9,\"42\":2}}],[\"mt19937\",{\"1\":{\"34\":1},\"2\":{\"46\":1}}],[\"mt19937算法可分为三个部分\",{\"1\":{\"34\":1}}],[\"mt19937即梅森旋转算法\",{\"1\":{\"33\":1}}],[\"mt19937分析\",{\"0\":{\"31\":1}}],[\"mersenne\",{\"1\":{\"33\":1}}],[\"minima\",{\"1\":{\"28\":1}}],[\"malloc\",{\"1\":{\"40\":1}}],[\"mask=0xffffffff\",{\"1\":{\"36\":2}}],[\"mask\",{\"1\":{\"36\":8,\"38\":2}}],[\"mahler\",{\"1\":{\"28\":1}}],[\"math\",{\"1\":{\"28\":1}}],[\"mathematics\",{\"1\":{\"28\":1}}],[\"m\",{\"1\":{\"9\":1,\"13\":7,\"23\":1,\"28\":7}}],[\"m=o\",{\"1\":{\"9\":1}}],[\"个数a1​\",{\"1\":{\"9\":1}}],[\"公钥为\",{\"1\":{\"23\":1}}],[\"公钥为从0\",{\"1\":{\"9\":1}}],[\"公钥密码\",{\"0\":{\"9\":1}}],[\"给定\",{\"1\":{\"16\":1}}],[\"给定大整数n\",{\"1\":{\"9\":1}}],[\"给定目标向量t∈rn\",{\"1\":{\"6\":1}}],[\"3−32位值\",{\"1\":{\"41\":1}}],[\"3989032602\",{\"1\":{\"36\":1,\"39\":1}}],[\"397\",{\"1\":{\"34\":1,\"38\":1}}],[\"30\",{\"1\":{\"34\":1,\"39\":3}}],[\"32位\",{\"1\":{\"38\":1}}],[\"32\",{\"1\":{\"28\":1,\"38\":2,\"39\":1,\"40\":8,\"41\":2}}],[\"348\",{\"1\":{\"28\":1}}],[\"333\",{\"1\":{\"28\":1}}],[\"37th\",{\"1\":{\"28\":1}}],[\"3​\",{\"1\":{\"18\":1}}],[\"3\",{\"1\":{\"9\":1,\"28\":2,\"41\":1}}],[\"上述思路部分的算法我们就不再介绍了\",{\"1\":{\"20\":1}}],[\"上述不等式的上下界分别由可见\",{\"1\":{\"19\":1}}],[\"上述三个命题的证明就不再说了\",{\"1\":{\"16\":1}}],[\"上述内容都是利用格来构造哈希函数提高抗碰撞能力\",{\"1\":{\"8\":1}}],[\"上\",{\"1\":{\"13\":1}}],[\"上面我们介绍了一些关于格的基本定义和历史工作\",{\"1\":{\"10\":1}}],[\"上面这句话的意思就是在格密码体系中我们可以避免很多特殊要求\",{\"1\":{\"5\":1}}],[\"2636928640为例来进行逆向处理\",{\"1\":{\"36\":1}}],[\"2636928640\",{\"1\":{\"34\":1,\"36\":3}}],[\"267\",{\"1\":{\"28\":1}}],[\"2kv个组合中每一个都在一个周期内出现次数相同\",{\"1\":{\"33\":1}}],[\"288\",{\"1\":{\"28\":1}}],[\"28th\",{\"1\":{\"28\":1}}],[\"246\",{\"1\":{\"28\":1}}],[\"229\",{\"1\":{\"28\":1}}],[\"224\",{\"1\":{\"28\":1}}],[\"290\",{\"1\":{\"28\":1}}],[\"279\",{\"1\":{\"28\":1}}],[\"2014\",{\"1\":{\"28\":1}}],[\"201\",{\"1\":{\"28\":1}}],[\"2011\",{\"1\":{\"28\":1}}],[\"2005\",{\"1\":{\"28\":1}}],[\"2004\",{\"1\":{\"28\":1}}],[\"2006\",{\"1\":{\"28\":1}}],[\"2=q​\",{\"1\":{\"24\":1}}],[\"2=det\",{\"1\":{\"12\":1}}],[\"2​\",{\"1\":{\"23\":1}}],[\"2≤4i+3​\",{\"1\":{\"19\":1}}],[\"2∣时称为size\",{\"1\":{\"19\":1}}],[\"2λj​−1\",{\"1\":{\"16\":1}}],[\"2bj​\",{\"1\":{\"16\":2}}],[\"2n​\",{\"1\":{\"9\":1}}],[\"2\",{\"1\":{\"8\":1,\"9\":2,\"16\":1,\"18\":2,\"21\":1,\"28\":4,\"34\":1,\"38\":2,\"41\":1}}],[\"a⊕c=d​\",{\"1\":{\"41\":1}}],[\"al\",{\"1\":{\"28\":1}}],[\"algorithmic\",{\"1\":{\"28\":1}}],[\"algorithms\",{\"1\":{\"28\":2}}],[\"akad\",{\"1\":{\"28\":1}}],[\"advances\",{\"1\":{\"28\":1}}],[\"aoˆut\",{\"1\":{\"28\":1}}],[\"a\",{\"1\":{\"28\":9}}],[\"at\",{\"1\":{\"28\":1}}],[\"available\",{\"1\":{\"28\":1}}],[\"acm\",{\"1\":{\"28\":4}}],[\"an\",{\"1\":{\"28\":1,\"40\":1}}],[\"ants\",{\"1\":{\"28\":1}}],[\"angew\",{\"1\":{\"28\":1}}],[\"and\",{\"1\":{\"28\":9}}],[\"annual\",{\"1\":{\"28\":1}}],[\"an​\",{\"1\":{\"23\":1}}],[\"ai0​​\",{\"1\":{\"9\":2}}],[\"a1​\",{\"1\":{\"9\":2}}],[\"am​都接近n\",{\"1\":{\"9\":1}}],[\"am​\",{\"1\":{\"9\":2}}],[\"ajtai\",{\"1\":{\"28\":1}}],[\"ajtai在上述的基础上又和dwork构建了一个公钥密码体系\",{\"1\":{\"9\":1}}],[\"ajtai最初提出了一类单向函数\",{\"1\":{\"8\":1}}],[\"apprsvp的最坏难度\",{\"1\":{\"8\":1}}],[\"apprsvp当c≥21​时非常困难\",{\"1\":{\"6\":1}}],[\"apprsvp\",{\"1\":{\"6\":1}}],[\"哈希函数\",{\"0\":{\"8\":1}}],[\"格l在c∈rn的数量l∩c是vol\",{\"1\":{\"18\":1}}],[\"格基密码\",{\"0\":{\"22\":1}}],[\"格基归约的目的是为了找到最短向量\",{\"1\":{\"18\":1}}],[\"格基归约\",{\"0\":{\"18\":1}}],[\"格基一定是构成子空间的一个极大无关向量组\",{\"1\":{\"11\":1}}],[\"格的模体积就是格基矩阵行列式的绝对值\",{\"1\":{\"12\":1}}],[\"格的秩d即子空间span\",{\"1\":{\"11\":1}}],[\"格的性质\",{\"0\":{\"10\":1}}],[\"格\",{\"1\":{\"11\":1}}],[\"格定义\",{\"0\":{\"11\":1}}],[\"格应用\",{\"0\":{\"7\":1}}],[\"格问题\",{\"0\":{\"6\":1}}],[\"算法所需时间将呈多项式增长\",{\"1\":{\"6\":1}}],[\"null\",{\"1\":{\"40\":3}}],[\"number中一样的方法\",{\"1\":{\"38\":1}}],[\"number中的数据时\",{\"1\":{\"37\":1}}],[\"number函数\",{\"0\":{\"36\":1},\"1\":{\"36\":1}}],[\"number\",{\"1\":{\"28\":1,\"34\":1,\"36\":2,\"40\":1}}],[\"negative\",{\"1\":{\"40\":1}}],[\"nearest\",{\"1\":{\"28\":1}}],[\"nederl\",{\"1\":{\"28\":1}}],[\"new\",{\"1\":{\"28\":2}}],[\"nomemory\",{\"1\":{\"40\":1}}],[\"nombres\",{\"1\":{\"28\":1}}],[\"non\",{\"1\":{\"40\":1}}],[\"notes\",{\"1\":{\"28\":2}}],[\"ntru\",{\"0\":{\"24\":1},\"1\":{\"28\":1}}],[\"n+1\",{\"1\":{\"23\":2}}],[\"n维球的体积是vr​\",{\"1\":{\"12\":1}}],[\"n2\",{\"1\":{\"9\":1}}],[\"n4\",{\"1\":{\"9\":1}}],[\"n−1中选取m\",{\"1\":{\"9\":1}}],[\"n​\",{\"1\":{\"9\":1}}],[\"n\",{\"0\":{\"49\":1},\"1\":{\"6\":2,\"18\":2,\"38\":2,\"39\":3}}],[\"最终通过此信息我们便能向前回推出sj​\",{\"1\":{\"42\":1}}],[\"最后在gf2上求解这个代数方程即可\",{\"1\":{\"43\":1}}],[\"最后讲了一点实际的攻击例子\",{\"1\":{\"27\":1}}],[\"最后这些hkz归约得到的bi∗​便是新格基\",{\"1\":{\"19\":1}}],[\"最后我们可以得到v1​−b1​\",{\"1\":{\"16\":1}}],[\"最近向量问题\",{\"1\":{\"6\":1}}],[\"最短线性无关向量问题\",{\"1\":{\"6\":1}}],[\"最短向量问题\",{\"1\":{\"6\":1}}],[\"满足bi​≡wai​\",{\"1\":{\"23\":1}}],[\"满足gcd\",{\"1\":{\"23\":1}}],[\"满足m>∑i=1n​ai​\",{\"1\":{\"23\":1}}],[\"满足ai​>∑k=1i−1​ak​\",{\"1\":{\"23\":1}}],[\"满足∥si​−t∥≤∥sj​−t∥\",{\"1\":{\"6\":1}}],[\"满足∥si​∥≤λn​\",{\"1\":{\"6\":1}}],[\"满足∥si​∥≤γ∥u∥\",{\"1\":{\"6\":1}}],[\"满足它比所有其他非平行最短向量短\",{\"1\":{\"6\":1}}],[\"唯一最短向量问题\",{\"1\":{\"6\":1}}],[\"s19967​\",{\"1\":{\"43\":1}}],[\"s19966​\",{\"1\":{\"43\":1}}],[\"s1​\",{\"1\":{\"43\":1}}],[\"s0​\",{\"1\":{\"43\":1}}],[\"s=\",{\"1\":{\"43\":2}}],[\"shift\",{\"1\":{\"36\":6,\"39\":2}}],[\"setstring\",{\"1\":{\"40\":1}}],[\"seed\",{\"1\":{\"34\":2,\"39\":5}}],[\"self\",{\"1\":{\"34\":21,\"39\":3,\"40\":3,\"42\":2}}],[\"static\",{\"1\":{\"40\":1}}],[\"state\",{\"1\":{\"38\":9,\"39\":2}}],[\"stern\",{\"1\":{\"28\":1}}],[\"stoc\",{\"1\":{\"28\":2}}],[\"solving\",{\"1\":{\"28\":1}}],[\"s\",{\"1\":{\"28\":2}}],[\"sum\",{\"1\":{\"28\":2}}],[\"subset\",{\"1\":{\"28\":2}}],[\"sublattice\",{\"1\":{\"13\":1}}],[\"successive\",{\"1\":{\"28\":1}}],[\"sur\",{\"1\":{\"28\":1}}],[\"sci\",{\"1\":{\"28\":1}}],[\"science\",{\"1\":{\"28\":3}}],[\"schnorr\",{\"1\":{\"28\":3}}],[\"schmidt\",{\"1\":{\"14\":1}}],[\"schmidt正交化\",{\"0\":{\"14\":1}}],[\"symp\",{\"1\":{\"28\":2}}],[\"springer\",{\"1\":{\"28\":4}}],[\"span\",{\"1\":{\"11\":2}}],[\"significant\",{\"1\":{\"40\":3}}],[\"si+624−1​\",{\"1\":{\"41\":1}}],[\"si+624−397​\",{\"1\":{\"41\":1}}],[\"si+397​\",{\"1\":{\"41\":1}}],[\"si+397​有关\",{\"1\":{\"38\":1,\"41\":1}}],[\"si+1​\",{\"1\":{\"38\":1,\"41\":1}}],[\"silverman\",{\"1\":{\"28\":2}}],[\"size\",{\"1\":{\"19\":1}}],[\"sivp\",{\"1\":{\"6\":1}}],[\"svp因子测量\",{\"0\":{\"26\":1}}],[\"svp归约为cvp\",{\"0\":{\"16\":1}}],[\"svp的难度来自于格中有不同的基\",{\"1\":{\"6\":1}}],[\"svp\",{\"1\":{\"6\":1}}],[\"找到线性组合满足w=∑λi​bi\",{\"1\":{\"21\":1}}],[\"找到格中非零向量si​\",{\"1\":{\"6\":1}}],[\"找到最短非零向量si​\",{\"1\":{\"6\":1}}],[\"找到n个线性无关向量si​\",{\"1\":{\"6\":1}}],[\"找到近似最短非零向量si​\",{\"1\":{\"6\":1}}],[\"找出格中的最短非零向量\",{\"1\":{\"6\":1}}],[\"近似最短向量问题\",{\"1\":{\"6\":1}}],[\"例如现在是\",{\"1\":{\"24\":1}}],[\"例如对于这个例子\",{\"1\":{\"24\":1}}],[\"例如\",{\"1\":{\"6\":1}}],[\"例如在rsa中\",{\"1\":{\"5\":1}}],[\"其state可以表示为\",{\"1\":{\"43\":1}}],[\"其实也就是不断地进行gso\",{\"1\":{\"20\":1}}],[\"其实也就是有些点无法被覆盖\",{\"1\":{\"11\":1}}],[\"其vol\",{\"1\":{\"12\":1}}],[\"其安全性基于usvp的最坏难度\",{\"1\":{\"9\":1}}],[\"其中行为最终输出out的最高位值\",{\"1\":{\"38\":1}}],[\"其中y\",{\"1\":{\"38\":1}}],[\"其中y可以看作已知\",{\"1\":{\"36\":1}}],[\"其中32位的mt19937\",{\"1\":{\"34\":1}}],[\"其中v=\",{\"1\":{\"23\":1}}],[\"其中u1​\",{\"1\":{\"18\":1}}],[\"其中u代表格中其他任意向量\",{\"1\":{\"6\":1}}],[\"其中格基b=\",{\"1\":{\"17\":1}}],[\"其中还有一类特殊的格与正交格很相似\",{\"1\":{\"13\":1}}],[\"其中的元素个数我们称为群指数\",{\"1\":{\"13\":1}}],[\"其中p\",{\"1\":{\"11\":1}}],[\"其中bi∗​代表bi​的gso\",{\"1\":{\"19\":1}}],[\"其中b\",{\"1\":{\"11\":1}}],[\"其中sj​代表格中其他非零向量\",{\"1\":{\"6\":1}}],[\"其内容为给定一个格基\",{\"1\":{\"6\":1}}],[\"其他密码体系都是基于平均性假设\",{\"1\":{\"5\":1}}],[\"这也意味着我们能够提取得到state中的原始数据\",{\"1\":{\"37\":1}}],[\"这样我们就可以在原做法的基础上得到一个更大的解的上界\",{\"1\":{\"24\":1}}],[\"这样我们才可以用lll求解得到\",{\"1\":{\"23\":1}}],[\"这样我们便可以取解决一些列最短向量问题\",{\"1\":{\"18\":1}}],[\"这很cool\",{\"1\":{\"18\":1}}],[\"这很重要\",{\"1\":{\"5\":1}}],[\"这是一种基于hermite不等式的格子基底缩减算法\",{\"1\":{\"18\":1}}],[\"这个不等式也叫做lovász条件\",{\"1\":{\"20\":1}}],[\"这个思路非常巧妙\",{\"1\":{\"16\":1}}],[\"这个理论上在学线代的时候就都学过了\",{\"1\":{\"14\":1}}],[\"这里为了方便编写便使用相同的字母作为一段\",{\"1\":{\"36\":1}}],[\"这里直接引用的是\",{\"1\":{\"24\":1}}],[\"这里只对背包密码算法做一个简单的介绍\",{\"1\":{\"23\":1}}],[\"这里涉及n维球体积公式\",{\"1\":{\"18\":1}}],[\"这里我们可以回顾之前的内容\",{\"1\":{\"43\":1}}],[\"这里我们主要介绍今天常用的lll算法\",{\"1\":{\"20\":1}}],[\"这里我们将深入讲解这些问题之间的联系以及如何解决它们\",{\"1\":{\"15\":1}}],[\"这里我们只看一下改进后的该密码系统\",{\"1\":{\"9\":1}}],[\"这里就不再记录分享了\",{\"1\":{\"14\":1}}],[\"这里就是说记以格点为中心半径为r的n维球b\",{\"1\":{\"12\":1}}],[\"这里还有关于投影格得到降秩的推论\",{\"1\":{\"13\":1}}],[\"这里的nc为多项式因子\",{\"1\":{\"6\":1}}],[\"这些向量的整系数组合构成的点集即为一个格\",{\"1\":{\"5\":1}}],[\"抗量子攻击\",{\"1\":{\"5\":1}}],[\"涉及的计算简单\",{\"1\":{\"5\":1}}],[\"从而让我们想要的目标向量变成svp的解或近似解\",{\"1\":{\"24\":1}}],[\"从而不一定能够从lll得到解\",{\"1\":{\"24\":1}}],[\"从而可以通过lll得到私钥\",{\"1\":{\"24\":1}}],[\"从而避免选择它们\",{\"1\":{\"5\":1}}],[\"从这里我们还能得到一个性质就是一定可以从一组极大无关向量组b1​\",{\"1\":{\"11\":1}}],[\"从这里开始我们将系统性学习格相关理论和性质\",{\"1\":{\"10\":1}}],[\"从18世纪开始\",{\"1\":{\"5\":1}}],[\"不适用特殊情况\",{\"1\":{\"19\":1}}],[\"不是全秩子格的秩严格小于d\",{\"1\":{\"13\":1}}],[\"不同于子空间\",{\"1\":{\"13\":1}}],[\"不相同\",{\"1\":{\"12\":1}}],[\"不接近n\",{\"1\":{\"9\":1}}],[\"不过写的时候发现干脆和rlwe一起介绍\",{\"1\":{\"25\":1}}],[\"不过实际上我们在攻击时目标可能并不完全符合密码标准或者说是一类自定义的密码体系\",{\"1\":{\"24\":1}}],[\"不过后续会用到这里的内容\",{\"1\":{\"19\":1}}],[\"不过这又引出了新的问题\",{\"1\":{\"18\":1}}],[\"不过不好的消息的上述内容是高斯启发\",{\"1\":{\"18\":1}}],[\"不过此类内容还是遇到投影格的应用再写吧\",{\"1\":{\"13\":1}}],[\"不过目前还没有量子算法可以超越经典算法解决格问题\",{\"1\":{\"9\":1}}],[\"不过注意上述两个密码系统安全性无法比较优劣\",{\"1\":{\"9\":1}}],[\"不过它在应用中总是很有效\",{\"1\":{\"6\":1}}],[\"不过我们主要是看格在密码学中的应用\",{\"1\":{\"5\":1}}],[\"不好\",{\"1\":{\"5\":1}}],[\"不断地发现一些因子\",{\"1\":{\"5\":1}}],[\"不断地选择因子\",{\"1\":{\"5\":1}}],[\"高斯和闵可夫斯基等数学家都对格有研究\",{\"1\":{\"5\":1}}],[\"拉格朗日\",{\"1\":{\"5\":1}}],[\"一般来说我们的目的就是让向量在每个方向的长度都一致\",{\"1\":{\"24\":1}}],[\"一般我们认为同维度下cvp比svp更难\",{\"1\":{\"16\":1}}],[\"一般我们认为nc\",{\"1\":{\"6\":1}}],[\"一维ntru\",{\"1\":{\"24\":1}}],[\"一组基当gso\",{\"1\":{\"19\":1}}],[\"一组格基为b=\",{\"1\":{\"12\":1}}],[\"一些思路\",{\"0\":{\"19\":1}}],[\"一些学习笔记\",{\"1\":{\"1\":1}}],[\"一个周期为p的w位整数的伪随机数序列xi​\",{\"1\":{\"33\":1}}],[\"一个格的每个元素都能视作另一个格的元素\",{\"1\":{\"13\":1}}],[\"一个r2中格的两组基\",{\"1\":{\"5\":1}}],[\"一是第一个基于usvp而不是svp\",{\"1\":{\"9\":1}}],[\"1≤j\",{\"1\":{\"42\":1}}],[\"1<<32\",{\"1\":{\"39\":1}}],[\"111\",{\"1\":{\"28\":1}}],[\"11\",{\"1\":{\"28\":1,\"34\":1,\"36\":2}}],[\"112\",{\"1\":{\"28\":1}}],[\"18\",{\"1\":{\"34\":1,\"36\":2}}],[\"1812433253\",{\"1\":{\"34\":1,\"39\":3}}],[\"1850\",{\"1\":{\"28\":1}}],[\"1845\",{\"1\":{\"28\":1}}],[\"15\",{\"1\":{\"24\":1,\"28\":1,\"34\":1,\"36\":2}}],[\"1423\",{\"1\":{\"28\":1}}],[\"141\",{\"1\":{\"28\":1}}],[\"14\",{\"1\":{\"24\":1,\"28\":1}}],[\"131\",{\"1\":{\"28\":2}}],[\"13\",{\"1\":{\"23\":1,\"28\":2}}],[\"128\",{\"1\":{\"28\":1}}],[\"1294\",{\"1\":{\"28\":1}}],[\"12\",{\"1\":{\"23\":1,\"28\":1}}],[\"108\",{\"1\":{\"28\":1}}],[\"10​dhdq​\",{\"1\":{\"24\":1}}],[\"10​hq​\",{\"1\":{\"24\":1}}],[\"10\",{\"1\":{\"21\":1,\"28\":2}}],[\"1985\",{\"1\":{\"28\":1}}],[\"1987\",{\"1\":{\"28\":1}}],[\"1986\",{\"1\":{\"28\":1}}],[\"1982年\",{\"1\":{\"18\":1}}],[\"1938\",{\"1\":{\"28\":1}}],[\"1998\",{\"1\":{\"28\":1}}],[\"1992\",{\"1\":{\"28\":1}}],[\"1990\",{\"1\":{\"28\":1}}],[\"1997\",{\"1\":{\"28\":1}}],[\"1996\",{\"1\":{\"28\":1}}],[\"1996年ajtai发现格不仅可以用来分析密码还可以来构建密码\",{\"1\":{\"5\":1}}],[\"1\",{\"1\":{\"5\":1,\"9\":2,\"12\":1,\"16\":1,\"17\":1,\"18\":3,\"20\":1,\"23\":1,\"24\":1,\"28\":4,\"34\":6,\"38\":10,\"39\":7,\"40\":3,\"43\":1,\"44\":1}}],[\"我们来考虑mt19937在f2​上的表现形式\",{\"1\":{\"43\":1}}],[\"我们总是能够利用足够多的约束来求解所有信息\",{\"1\":{\"43\":1}}],[\"我们的本质是通过已知信息推出与之直接关联的未知信息\",{\"1\":{\"43\":1}}],[\"我们是否还能利用扩散得到足够多的约束信息\",{\"1\":{\"43\":1}}],[\"我们便能知道\",{\"1\":{\"42\":1}}],[\"我们便可以向前恢复得到y的所有值\",{\"1\":{\"38\":1}}],[\"我们便可以向前恢复得到eeffffg\",{\"1\":{\"36\":1}}],[\"我们不妨考虑一些最极端的情况\",{\"1\":{\"40\":1}}],[\"我们有\",{\"1\":{\"38\":1,\"43\":1}}],[\"我们将代码改为y\",{\"1\":{\"36\":1}}],[\"我们以y\",{\"1\":{\"36\":1}}],[\"我们可以发现第一轮的初始状态是通过seed生成的\",{\"1\":{\"39\":1}}],[\"我们可以发现新的值只和si​\",{\"1\":{\"38\":1}}],[\"我们可以给原格点较小的一列乘上一个数d\",{\"1\":{\"24\":1}}],[\"我们可以这样定义格\",{\"1\":{\"5\":1}}],[\"我们去掉极限号\",{\"1\":{\"18\":1}}],[\"我们考虑上述cvp的解为x=∑λi​bi​\",{\"1\":{\"17\":1}}],[\"我们更关注计算上的内容\",{\"1\":{\"11\":1}}],[\"我们通常将格定义为rn的离散子群\",{\"1\":{\"11\":1}}],[\"我们无须考虑这类问题\",{\"1\":{\"5\":1}}],[\"我们构建n时要避免选择一些特殊的因子\",{\"1\":{\"5\":1}}],[\"我们把v1​\",{\"1\":{\"5\":1}}],[\"==\",{\"1\":{\"34\":1,\"36\":1,\"38\":1,\"39\":1,\"40\":2}}],[\"=c\",{\"1\":{\"23\":1}}],[\"=1\",{\"1\":{\"23\":1}}],[\"=2πen​​\",{\"1\":{\"18\":1}}],[\"=u1​\",{\"1\":{\"18\":1}}],[\"=​∣c∣1​∣b1​∣0​⋯\",{\"1\":{\"17\":1}}],[\"=∥u∥\",{\"1\":{\"16\":2}}],[\"=0∣x∈l\",{\"1\":{\"13\":1}}],[\"=bty是一个整数向量\",{\"1\":{\"13\":1}}],[\"=πspan\",{\"1\":{\"13\":1}}],[\"=vol\",{\"1\":{\"13\":1,\"24\":1}}],[\"=dim\",{\"1\":{\"13\":1}}],[\"=r→∞lim​∣b\",{\"1\":{\"12\":1}}],[\"=δ\",{\"1\":{\"12\":1}}],[\"=i=1∑d​\",{\"1\":{\"11\":2}}],[\"=span\",{\"1\":{\"11\":1}}],[\"=\",{\"1\":{\"5\":1,\"11\":3,\"13\":5,\"16\":1,\"24\":1,\"34\":14,\"36\":15,\"38\":6,\"39\":12,\"40\":9,\"42\":1}}],[\"little\",{\"1\":{\"40\":2}}],[\"linear\",{\"1\":{\"28\":1}}],[\"least\",{\"1\":{\"40\":2}}],[\"learning\",{\"1\":{\"28\":1}}],[\"len\",{\"1\":{\"38\":1}}],[\"lenstra和lov´asz发表了lenstra\",{\"1\":{\"18\":1}}],[\"lenstra\",{\"1\":{\"18\":2,\"28\":1}}],[\"left\",{\"1\":{\"36\":3}}],[\"lecture\",{\"1\":{\"28\":2}}],[\"lettre\",{\"1\":{\"28\":1}}],[\"lettres\",{\"1\":{\"28\":1}}],[\"lwe\",{\"0\":{\"25\":1}}],[\"l=\",{\"1\":{\"24\":2}}],[\"l=​100⋮00​010⋮00​001⋮00​⋯⋯⋯⋱⋯⋯​000⋮10​b1​b2​b2​⋮bn​−c​​\",{\"1\":{\"23\":1}}],[\"last\",{\"1\":{\"39\":6}}],[\"lamacchia\",{\"1\":{\"28\":1}}],[\"lagarias\",{\"1\":{\"28\":2}}],[\"lagrange和gauss都发明了一种将秩为2的格基二次型归约算法\",{\"1\":{\"19\":1}}],[\"la\",{\"1\":{\"28\":1}}],[\"lattice\",{\"0\":{\"48\":1},\"1\":{\"13\":2,\"28\":10},\"2\":{\"30\":1}}],[\"lattices\",{\"1\":{\"13\":1,\"28\":1}}],[\"lll算法是一个多项式时间复杂度的算法\",{\"1\":{\"20\":1}}],[\"lll算法\",{\"1\":{\"20\":1}}],[\"lll\",{\"1\":{\"18\":1}}],[\"long\",{\"1\":{\"40\":1}}],[\"low\",{\"1\":{\"28\":2,\"38\":2}}],[\"lovász\",{\"1\":{\"28\":1}}],[\"lov´asz算法\",{\"1\":{\"18\":1}}],[\"logn\",{\"1\":{\"9\":1}}],[\"l⊥=\",{\"1\":{\"13\":1}}],[\"l×=\",{\"1\":{\"13\":1}}],[\"l\",{\"1\":{\"5\":1,\"6\":1,\"11\":3,\"12\":4,\"13\":8,\"18\":11,\"19\":2,\"21\":1,\"23\":3,\"24\":3,\"28\":1}}],[\"即我们能够得到ggghhhh的结果\",{\"1\":{\"36\":1}}],[\"即变得\",{\"1\":{\"24\":1}}],[\"即等式的右边取值为1\",{\"1\":{\"18\":1}}],[\"即每个y\",{\"1\":{\"13\":1}}],[\"即内积\",{\"1\":{\"13\":1}}],[\"即任意x∈d\",{\"1\":{\"11\":1}}],[\"即\",{\"1\":{\"5\":1,\"13\":1}}],[\"valueerror\",{\"1\":{\"40\":1}}],[\"van\",{\"1\":{\"28\":1}}],[\"version\",{\"1\":{\"28\":1}}],[\"v=w−1c≡i=1∑n​vi​ai​\",{\"1\":{\"23\":1}}],[\"vi​∈\",{\"1\":{\"23\":1}}],[\"vi​\",{\"1\":{\"23\":1}}],[\"vr​​≈∣b\",{\"1\":{\"18\":1}}],[\"v\",{\"1\":{\"16\":2}}],[\"vd​−bd​便是格l\",{\"1\":{\"16\":1}}],[\"vol\",{\"1\":{\"12\":2,\"13\":2,\"18\":5}}],[\"volume\",{\"0\":{\"12\":1},\"1\":{\"28\":3}}],[\"vn​称为格l的一组基\",{\"1\":{\"5\":1}}],[\"vn​\",{\"1\":{\"5\":1,\"23\":1}}],[\"vn​∈rn\",{\"1\":{\"5\":1}}],[\"v1​\",{\"1\":{\"5\":1,\"23\":1}}],[\"v2​\",{\"1\":{\"5\":3,\"23\":1}}],[\"什么是格\",{\"0\":{\"5\":1}}],[\"前言\",{\"0\":{\"4\":1,\"32\":1},\"1\":{\"27\":2}}],[\"密码学\",{\"0\":{\"1\":1},\"1\":{\"27\":1},\"2\":{\"2\":1,\"29\":1,\"45\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
